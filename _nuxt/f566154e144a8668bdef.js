(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{391:function(e,n){e.exports={body:'## The Observer Pattern\n\n### Introducci&oacute;n\n\nEn este capitulo, presentaremos otros de los patrones muy frecuentemente utilizado por los desarrolladores. El __patr&oacute;n Observer (Observador)__ permite notificar a los subscriptores si se han producido cambios en un objeto.\n\n### GPS City Visit\n\nUna agencia de turismo quiere proporcionar a los usuarios una aplicaci&oacute;n GPS, para brindarle informaci&oacute;n sobre diferentes entidades de la ciudad. El visitante, desde un dispositivo colocado en su veh&iacute;culo particular, deber&iacute;a ser informado autom&aacute;ticamente cada vez que visita una ciudad, sobre el clima local, los lugares de esparcimiento, las noticias m&aacute;s destacadas de la ciudad, entre otros factores.\n\nNos piden a nosotros, desarrollar la aplicaci&oacute;n. Permitiendo a&ntilde;adir a futuro, nuevas entidades. Actualmente la agencia cuenta con informaci&oacute;n sobre el clima, las noticias destacadas de la ciudad y la oferta hotelera existente proveniente de una cadena muy reconocida.\n\nNosotros podr&iacute;amos pensar en elaborar una clase como la siguiente:\n\n![ObserverPattern](https://res.cloudinary.com/webxander/image/upload/v1545464516/patterns/ObserverPattern.jpg)\n\nCada vez que la aplicaci&oacute;n ingresa a una nueva ciudad, se invocar&iacute;a al m&eacute;todo `visit()` pas&aacute;ndole como par&aacute;metro la nueva ciudad. El m&eacute;todo `updateCity(City city);` lo que hace es actualizar las diferentes entidades con la nueva ciudad.\n\nUna implementaci&oacute;n que podemos dise&ntilde;ar, es la siguiente:\n\n```java\n    public class GpsCity {\n\n        //some fields data;\n\n        public void updateCity(City newCity)\n        {\n            city = newCity;\n\n            sHotel = new SystemHotel(city);\n\n            weather = new Weather(city);\n\n            featureNews = new News(city);\n        }\n\n        public void visit(City newCity)\n        {\n            updateCity(newCity);\n\n            getDisplayWelcome();\n\n            getSystemHotel();\n\n            getWeather();\n\n            getFeatureNews();\n\n        }\n\n        //other methods..\n    }\n```\n\nLos m&eacute;todos `get` obtienen informaci&oacute;n de sus respectivas entidades. No conocemos la implementaci&oacute;n de las clases de las entidades, solo conocemos que es lo que hacen y como obtener la informaci&oacute;n pertinente.\n\nEl problema con esta primer versi&oacute;n radica en que, si deseamos a&ntilde;adir una nueva entidad, debemos reestructurar nuestra aplicaci&oacute;n, por lo que se pierde flexibilidad.\n\nAdem&aacute;s, el c&oacute;digo actual no nos permite modificar en tiempo de ejecuci&oacute;n, que entidades queremos obtener. El sistema nos obliga a mostrar la informaci&oacute;n de todas las entidades sin poder realizar un filtrado.\n\nVemos que en el evento `updateCity()`, crea todas las entidades y asocia a cada una de ellas, la ciudad visitada actual. Como observamos, todas las entidades tienen una interfaz en com&uacute;n.\n\nEs hora de poner en pr&aacute;ctica el uso del __patr&oacute;n Observador (Observer Pattern)__ en nuestra aplicaci&oacute;n.\n\n### Definici&oacute;n del patr&oacute;n observador\n\nCuando usted est&aacute; tratando de imaginar el patr&oacute;n de observador, un servicio de suscripci&oacute;n a un peri&oacute;dico con su editor y los suscriptores es una buena manera de visualizar el patr&oacute;n. Sin embargo, en el mundo real, normalmente ver&aacute;s el patr&oacute;n de observador definido de esta manera:\n\n::: info\n\n#### __Definici&oacute;n__\n\n__El patr&oacute;n observador__ define una dependencia de uno a muchos entre los objetos, de modo que cuando un objeto cambia de estado, todos sus dependientes son notificados y actualizados autom&aacute;ticamente.\n:::\n\nRelacionemos esta definici&oacute;n con la forma en que hemos estado hablando sobre el patr&oacute;n:\n\nEl sujeto y los observadores definen la relaci&oacute;n uno a muchos. Los observadores dependen del tema, de modo que cuando el estado del sujeto cambia, los observadores reciben una notificaci&oacute;n. Dependiendo del estilo de notificaci&oacute;n, el observador tambi&eacute;n puede actualizarse con nuevos valores. Como descubrir&aacute;, hay algunas formas diferentes de implementar el patr&oacute;n de observador, pero la mayor&iacute;a gira en torno a un dise&ntilde;o de clase que incluye interfaces de sujeto y observador. Vamos a ver...\n\n![ObserverPattern](https://res.cloudinary.com/webxander/image/upload/v1545464516/patterns/ObserverDiagram.png)\n\n### El poder del bajo acoplamiento\n\nCuando dos objetos est&aacute;n ligeramente acoplados, pueden interactuar, pero tienen muy poco conocimiento el uno del otro. El Patr&oacute;n observador proporciona un dise&ntilde;o de objeto donde los sujetos y los observadores est&aacute;n acoplados de manera flexible.\n\n&iquest;Por qu&eacute;?\n\nLo &uacute;nico que el sujeto sabe sobre un observador es que implementa una determinada interfaz (la interfaz de observador). No necesita saber la clase concreta del observador, lo que hace, o cualquier otra cosa al respecto.\n\nPodemos a&ntilde;adir nuevos observadores en cualquier momento. Debido a que el sujeto depende solo de una lista de objetos que implementan la interfaz de observador, podemos agregar observadores nuevos cuando queramos. De hecho, podemos reemplazar cualquier observador en tiempo de ejecuci&oacute;n con otro observador y el sujeto seguir&aacute; funcionando. Asimismo, podemos eliminar observadores en cualquier momento.\n\nNunca necesitamos modificar al sujeto para agregar nuevos tipos de observadores. Digamos que tenemos una nueva clase concreta que debe ser un observador. No necesitamos realizar ning&uacute;n cambio en al sujeto para adaptarse al nuevo tipo de clase, todo lo que tenemos que hacer es implementar la interfaz de observador en la nueva clase y registrarse como observador. Al sujeto no le importa; entregar&aacute; notificaciones a cualquier objeto que implemente la interfaz de observador.\n\nPodemos reutilizar sujetos u observadores independientemente unos de otros. Si tenemos otro uso para un sujeto o un observador, podemos reutilizarlos f&aacute;cilmente porque los dos no est&aacute;n estrechamente acoplados. Los cambios en el sujeto o en un observador no afectar&aacute;n al otro. Debido a que los dos est&aacute;n acoplados libremente, somos libres de realizar cambios en cualquiera de los dos, siempre y cuando los objetos sigan cumpliendo con sus obligaciones de implementar las interfaces del sujeto o del observador.\n\nLos dise&ntilde;os poco acoplados nos permiten construir sistemas OO flexibles que pueden manejar el cambio porque minimizan la interdependencia entre los objetos.\n\n### Dise&ntilde;ando la aplicaci&oacute;n GPS City\n\n![ObserverPattern](https://res.cloudinary.com/webxander/image/upload/v1545464516/patterns/ObserverPattern-AppDiagram.jpg)\n\nImplementando la aplicaci&oacute;n GPS City.\n\nVamos a comenzar nuestra implementaci&oacute;n usando el diagrama de clases. M&aacute;s adelante en este cap&iacute;tulo veremos que java proporciona alg&uacute;n soporte incorporado para el __patr&oacute;n Observer__, sin embargo, vamos a ensuciarnos las manos y escribir las nuestras por ahora. Mientras que en algunos casos puedes usar el soporte incorporado de Java, en muchos casos es m&aacute;s flexible construir el tuyo (y no es tan dif&iacute;cil). Entonces, comencemos con las interfaces:\n\n```java\n\n\n    public interface Observer {\n\n        public void update(City city);\n    }\n\n```\n\nLa interfaz `Observer` es implementada por todos los observadores, ellos tienen que implementar el m&eacute;todo `update()`. Aqu&iacute; le pasamos la ciudad actual a los observadores.\n\n```java\n        public interface Subject {\n\n            public void registerObserver(Observer o);\n            public void unregisterObserver(Observer o);\n\n            public void notifyObserver();\n\n        }\n```\n\nLos m&eacute;todos `registerObserver()` y `unregisterObserver()` obtienen un `Observer` como argumento; que es el `Observer` a ser registrado o eliminado.\n\nEl m&eacute;todo `notifyObserver()` es llamado para notificar a todos los observadores cuando el estado del sujeto ha sido cambiado.\n\n```java\n\n        public interface DisplayElement {\n\n            public void display();\n\n        }\n\n```\n\nAhora vamos a implementar las clases correspondientes.\n\n```java\n\n        public class GpsCity implements Subject{\n\n            private ArrayList observers;\n\n            public City city;\n\n            public GpsCity(){\n                observers = new ArrayList();\n            }\n\n            public void updateCity(City newCity){\n\n                city = newCity;\n\n            }\n\n            public void visit(City newCity)\n            {\n\n                updateCity(newCity);\n\n                getDisplayWelcome();\n\n                notifyObserver();\n\n            }\n\n            public City getCity()\n            {\n                return city;\n            }\n\n            public void getDisplayWelcome() {\n                System.out.println("Visitando... " + city.getName());\n            }\n\n            @Override\n            public void registerObserver(Observer o) {\n                observers.add(o);\n            }\n\n            @Override\n            public void unregisterObserver(Observer o) {\n\n                int i = observers.indexOf(o);\n                if (i>=0){\n                    observers.remove(i);\n                }\n\n            }\n\n            @Override\n            public void notifyObserver() {\n\n                for(int i = 0; i < observers.size(); i++){\n                    Observer observer = (Observer) observers.get(i);\n                    observer.update(city);\n                }\n            }\n        }\n\n```\n\nEn Java, para poder utilizar la clase `ArrayList` debe importarla a&ntilde;adiendo en la cabecera `import java.util.ArrayList;`\n\n```java\n    public class City {\n\n        private String name;\n\n        public City(String newCityName)\n        {\n            name = newCityName;\n        }\n\n        public String getName() {\n            return name;\n        }\n\n    }\n```\n\n```java\n    public class News implements Observer, DisplayElement {\n\n        private City city;\n\n        public News(Subject gpsCity) {\n\n            gpsCity.registerObserver(this);\n\n        }\n\n        public void getFeaturedNews() {\n            System.out.println("Estas son las noticias descatadas para " + city.getName());\n        }\n\n        @Override\n        public void update(City city) {\n            this.city = city;\n            display();\n        }\n\n        @Override\n        public void display() {\n            getFeaturedNews();\n        }\n\n    }\n\n```\n\n```java\n    public class Weather implements Observer, DisplayElement {\n\n        private City city;\n\n        public Weather(Subject gpsCity)\n        {\n            gpsCity.registerObserver(this);\n        }\n\n        public void show() {\n            System.out.println("Tiempo para la ciudad de " + city.getName());\n        }\n\n        public void update(City city) {\n            this.city = city;\n            display();\n        }\n\n        public void display() {\n            show();\n        }\n\n    }\n\n```\n\nAhora implementaremos un test para comprobar la funcionalidad de la aplicaci&oacute;n.\n\n```java\n    public class GgsCityTest {\n        public static void main(String[] args)\n        {\n            GpsCity gpscity = new GpsCity();\n\n            Weather weather = new Weather(gpscity);\n            News news = new News(gpscity);\n\n            gpscity.visit(new City("Mar del Plata"));\n\n            gpscity.visit(new City("Tandil"));\n\n        }\n    }\n\n```\n\nComo podemos apreciar, cada vez que se ejecuta el m&eacute;todo `visit()`, se dispara el evento `update()` para que las diferentes entidades actualicen sus estados con la nueva ciudad ingresada. Veamos la salida en pantalla el resultado correspondiente.\n\n![ObserverPattern](https://res.cloudinary.com/webxander/image/upload/v1545464516/patterns/gpstext.png)\n',html:'<h2>The Observer Pattern</h2>\n<h3>Introducción</h3>\n<p>En este capitulo, presentaremos otros de los patrones muy frecuentemente utilizado por los desarrolladores. El <strong>patrón Observer (Observador)</strong> permite notificar a los subscriptores si se han producido cambios en un objeto.</p>\n<h3>GPS City Visit</h3>\n<p>Una agencia de turismo quiere proporcionar a los usuarios una aplicación GPS, para brindarle información sobre diferentes entidades de la ciudad. El visitante, desde un dispositivo colocado en su vehículo particular, debería ser informado automáticamente cada vez que visita una ciudad, sobre el clima local, los lugares de esparcimiento, las noticias más destacadas de la ciudad, entre otros factores.</p>\n<p>Nos piden a nosotros, desarrollar la aplicación. Permitiendo añadir a futuro, nuevas entidades. Actualmente la agencia cuenta con información sobre el clima, las noticias destacadas de la ciudad y la oferta hotelera existente proveniente de una cadena muy reconocida.</p>\n<p>Nosotros podríamos pensar en elaborar una clase como la siguiente:</p>\n<p><img src="https://res.cloudinary.com/webxander/image/upload/v1545464516/patterns/ObserverPattern.jpg" alt="ObserverPattern"></p>\n<p>Cada vez que la aplicación ingresa a una nueva ciudad, se invocaría al método <code>visit()</code> pasándole como parámetro la nueva ciudad. El método <code>updateCity(City city);</code> lo que hace es actualizar las diferentes entidades con la nueva ciudad.</p>\n<p>Una implementación que podemos diseñar, es la siguiente:</p>\n<pre><code class="language-java">    public class GpsCity {\n\n        //some fields data;\n\n        public void updateCity(City newCity)\n        {\n            city = newCity;\n\n            sHotel = new SystemHotel(city);\n\n            weather = new Weather(city);\n\n            featureNews = new News(city);\n        }\n\n        public void visit(City newCity)\n        {\n            updateCity(newCity);\n\n            getDisplayWelcome();\n\n            getSystemHotel();\n\n            getWeather();\n\n            getFeatureNews();\n\n        }\n\n        //other methods..\n    }\n</code></pre>\n<p>Los métodos <code>get</code> obtienen información de sus respectivas entidades. No conocemos la implementación de las clases de las entidades, solo conocemos que es lo que hacen y como obtener la información pertinente.</p>\n<p>El problema con esta primer versión radica en que, si deseamos añadir una nueva entidad, debemos reestructurar nuestra aplicación, por lo que se pierde flexibilidad.</p>\n<p>Además, el código actual no nos permite modificar en tiempo de ejecución, que entidades queremos obtener. El sistema nos obliga a mostrar la información de todas las entidades sin poder realizar un filtrado.</p>\n<p>Vemos que en el evento <code>updateCity()</code>, crea todas las entidades y asocia a cada una de ellas, la ciudad visitada actual. Como observamos, todas las entidades tienen una interfaz en común.</p>\n<p>Es hora de poner en práctica el uso del <strong>patrón Observador (Observer Pattern)</strong> en nuestra aplicación.</p>\n<h3>Definición del patrón observador</h3>\n<p>Cuando usted está tratando de imaginar el patrón de observador, un servicio de suscripción a un periódico con su editor y los suscriptores es una buena manera de visualizar el patrón. Sin embargo, en el mundo real, normalmente verás el patrón de observador definido de esta manera:</p>\n<p>::: info</p>\n<h4><strong>Definición</strong></h4>\n<p><strong>El patrón observador</strong> define una dependencia de uno a muchos entre los objetos, de modo que cuando un objeto cambia de estado, todos sus dependientes son notificados y actualizados automáticamente.\n:::</p>\n<p>Relacionemos esta definición con la forma en que hemos estado hablando sobre el patrón:</p>\n<p>El sujeto y los observadores definen la relación uno a muchos. Los observadores dependen del tema, de modo que cuando el estado del sujeto cambia, los observadores reciben una notificación. Dependiendo del estilo de notificación, el observador también puede actualizarse con nuevos valores. Como descubrirá, hay algunas formas diferentes de implementar el patrón de observador, pero la mayoría gira en torno a un diseño de clase que incluye interfaces de sujeto y observador. Vamos a ver...</p>\n<p><img src="https://res.cloudinary.com/webxander/image/upload/v1545464516/patterns/ObserverDiagram.png" alt="ObserverPattern"></p>\n<h3>El poder del bajo acoplamiento</h3>\n<p>Cuando dos objetos están ligeramente acoplados, pueden interactuar, pero tienen muy poco conocimiento el uno del otro. El Patrón observador proporciona un diseño de objeto donde los sujetos y los observadores están acoplados de manera flexible.</p>\n<p>¿Por qué?</p>\n<p>Lo único que el sujeto sabe sobre un observador es que implementa una determinada interfaz (la interfaz de observador). No necesita saber la clase concreta del observador, lo que hace, o cualquier otra cosa al respecto.</p>\n<p>Podemos añadir nuevos observadores en cualquier momento. Debido a que el sujeto depende solo de una lista de objetos que implementan la interfaz de observador, podemos agregar observadores nuevos cuando queramos. De hecho, podemos reemplazar cualquier observador en tiempo de ejecución con otro observador y el sujeto seguirá funcionando. Asimismo, podemos eliminar observadores en cualquier momento.</p>\n<p>Nunca necesitamos modificar al sujeto para agregar nuevos tipos de observadores. Digamos que tenemos una nueva clase concreta que debe ser un observador. No necesitamos realizar ningún cambio en al sujeto para adaptarse al nuevo tipo de clase, todo lo que tenemos que hacer es implementar la interfaz de observador en la nueva clase y registrarse como observador. Al sujeto no le importa; entregará notificaciones a cualquier objeto que implemente la interfaz de observador.</p>\n<p>Podemos reutilizar sujetos u observadores independientemente unos de otros. Si tenemos otro uso para un sujeto o un observador, podemos reutilizarlos fácilmente porque los dos no están estrechamente acoplados. Los cambios en el sujeto o en un observador no afectarán al otro. Debido a que los dos están acoplados libremente, somos libres de realizar cambios en cualquiera de los dos, siempre y cuando los objetos sigan cumpliendo con sus obligaciones de implementar las interfaces del sujeto o del observador.</p>\n<p>Los diseños poco acoplados nos permiten construir sistemas OO flexibles que pueden manejar el cambio porque minimizan la interdependencia entre los objetos.</p>\n<h3>Diseñando la aplicación GPS City</h3>\n<p><img src="https://res.cloudinary.com/webxander/image/upload/v1545464516/patterns/ObserverPattern-AppDiagram.jpg" alt="ObserverPattern"></p>\n<p>Implementando la aplicación GPS City.</p>\n<p>Vamos a comenzar nuestra implementación usando el diagrama de clases. Más adelante en este capítulo veremos que java proporciona algún soporte incorporado para el <strong>patrón Observer</strong>, sin embargo, vamos a ensuciarnos las manos y escribir las nuestras por ahora. Mientras que en algunos casos puedes usar el soporte incorporado de Java, en muchos casos es más flexible construir el tuyo (y no es tan difícil). Entonces, comencemos con las interfaces:</p>\n<pre><code class="language-java">\n\n    public interface Observer {\n\n        public void update(City city);\n    }\n\n</code></pre>\n<p>La interfaz <code>Observer</code> es implementada por todos los observadores, ellos tienen que implementar el método <code>update()</code>. Aquí le pasamos la ciudad actual a los observadores.</p>\n<pre><code class="language-java">        public interface Subject {\n\n            public void registerObserver(Observer o);\n            public void unregisterObserver(Observer o);\n\n            public void notifyObserver();\n\n        }\n</code></pre>\n<p>Los métodos <code>registerObserver()</code> y <code>unregisterObserver()</code> obtienen un <code>Observer</code> como argumento; que es el <code>Observer</code> a ser registrado o eliminado.</p>\n<p>El método <code>notifyObserver()</code> es llamado para notificar a todos los observadores cuando el estado del sujeto ha sido cambiado.</p>\n<pre><code class="language-java">\n        public interface DisplayElement {\n\n            public void display();\n\n        }\n\n</code></pre>\n<p>Ahora vamos a implementar las clases correspondientes.</p>\n<pre><code class="language-java">\n        public class GpsCity implements Subject{\n\n            private ArrayList observers;\n\n            public City city;\n\n            public GpsCity(){\n                observers = new ArrayList();\n            }\n\n            public void updateCity(City newCity){\n\n                city = newCity;\n\n            }\n\n            public void visit(City newCity)\n            {\n\n                updateCity(newCity);\n\n                getDisplayWelcome();\n\n                notifyObserver();\n\n            }\n\n            public City getCity()\n            {\n                return city;\n            }\n\n            public void getDisplayWelcome() {\n                System.out.println(&quot;Visitando... &quot; + city.getName());\n            }\n\n            @Override\n            public void registerObserver(Observer o) {\n                observers.add(o);\n            }\n\n            @Override\n            public void unregisterObserver(Observer o) {\n\n                int i = observers.indexOf(o);\n                if (i&gt;=0){\n                    observers.remove(i);\n                }\n\n            }\n\n            @Override\n            public void notifyObserver() {\n\n                for(int i = 0; i &lt; observers.size(); i++){\n                    Observer observer = (Observer) observers.get(i);\n                    observer.update(city);\n                }\n            }\n        }\n\n</code></pre>\n<p>En Java, para poder utilizar la clase <code>ArrayList</code> debe importarla añadiendo en la cabecera <code>import java.util.ArrayList;</code></p>\n<pre><code class="language-java">    public class City {\n\n        private String name;\n\n        public City(String newCityName)\n        {\n            name = newCityName;\n        }\n\n        public String getName() {\n            return name;\n        }\n\n    }\n</code></pre>\n<pre><code class="language-java">    public class News implements Observer, DisplayElement {\n\n        private City city;\n\n        public News(Subject gpsCity) {\n\n            gpsCity.registerObserver(this);\n\n        }\n\n        public void getFeaturedNews() {\n            System.out.println(&quot;Estas son las noticias descatadas para &quot; + city.getName());\n        }\n\n        @Override\n        public void update(City city) {\n            this.city = city;\n            display();\n        }\n\n        @Override\n        public void display() {\n            getFeaturedNews();\n        }\n\n    }\n\n</code></pre>\n<pre><code class="language-java">    public class Weather implements Observer, DisplayElement {\n\n        private City city;\n\n        public Weather(Subject gpsCity)\n        {\n            gpsCity.registerObserver(this);\n        }\n\n        public void show() {\n            System.out.println(&quot;Tiempo para la ciudad de &quot; + city.getName());\n        }\n\n        public void update(City city) {\n            this.city = city;\n            display();\n        }\n\n        public void display() {\n            show();\n        }\n\n    }\n\n</code></pre>\n<p>Ahora implementaremos un test para comprobar la funcionalidad de la aplicación.</p>\n<pre><code class="language-java">    public class GgsCityTest {\n        public static void main(String[] args)\n        {\n            GpsCity gpscity = new GpsCity();\n\n            Weather weather = new Weather(gpscity);\n            News news = new News(gpscity);\n\n            gpscity.visit(new City(&quot;Mar del Plata&quot;));\n\n            gpscity.visit(new City(&quot;Tandil&quot;));\n\n        }\n    }\n\n</code></pre>\n<p>Como podemos apreciar, cada vez que se ejecuta el método <code>visit()</code>, se dispara el evento <code>update()</code> para que las diferentes entidades actualicen sus estados con la nueva ciudad ingresada. Veamos la salida en pantalla el resultado correspondiente.</p>\n<p><img src="https://res.cloudinary.com/webxander/image/upload/v1545464516/patterns/gpstext.png" alt="ObserverPattern"></p>\n',attributes:{name:"the-observer-pattern",title:"The Observer Pattern",year:"21 de Julio de 2019",color:"#8e7964",trans:"the-observer-pattern",id:"the-observer-pattern",description:"En este articulo, presentaremos otros de los patrones muy frecuentemente utilizado. El patrón Observer (Observador) permite notificar a los subscriptores si se han producido cambios en un objeto.\n",_meta:{resourcePath:"/home/travis/build/alejandrocayssials/nuxtblog/contents/articles/the-observer-pattern.md"}},vue:{render:"return function render() { var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _vm._m(0) }",staticRenderFns:'return [function () { var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(\'div\',{staticClass:"dynamicMarkdown"},[_c(\'h2\',[_vm._v("The Observer Pattern")]),_vm._v(" "),_c(\'h3\',[_vm._v("Introducción")]),_vm._v(" "),_c(\'p\',[_vm._v("En este capitulo, presentaremos otros de los patrones muy frecuentemente utilizado por los desarrolladores. El "),_c(\'strong\',[_vm._v("patrón Observer (Observador)")]),_vm._v(" permite notificar a los subscriptores si se han producido cambios en un objeto.")]),_vm._v(" "),_c(\'h3\',[_vm._v("GPS City Visit")]),_vm._v(" "),_c(\'p\',[_vm._v("Una agencia de turismo quiere proporcionar a los usuarios una aplicación GPS, para brindarle información sobre diferentes entidades de la ciudad. El visitante, desde un dispositivo colocado en su vehículo particular, debería ser informado automáticamente cada vez que visita una ciudad, sobre el clima local, los lugares de esparcimiento, las noticias más destacadas de la ciudad, entre otros factores.")]),_vm._v(" "),_c(\'p\',[_vm._v("Nos piden a nosotros, desarrollar la aplicación. Permitiendo añadir a futuro, nuevas entidades. Actualmente la agencia cuenta con información sobre el clima, las noticias destacadas de la ciudad y la oferta hotelera existente proveniente de una cadena muy reconocida.")]),_vm._v(" "),_c(\'p\',[_vm._v("Nosotros podríamos pensar en elaborar una clase como la siguiente:")]),_vm._v(" "),_c(\'p\',[_c(\'img\',{attrs:{"src":"https://res.cloudinary.com/webxander/image/upload/v1545464516/patterns/ObserverPattern.jpg","alt":"ObserverPattern"}})]),_vm._v(" "),_c(\'p\',[_vm._v("Cada vez que la aplicación ingresa a una nueva ciudad, se invocaría al método "),_c(\'code\',{pre:true},[_vm._v("visit()")]),_vm._v(" pasándole como parámetro la nueva ciudad. El método "),_c(\'code\',{pre:true},[_vm._v("updateCity(City city);")]),_vm._v(" lo que hace es actualizar las diferentes entidades con la nueva ciudad.")]),_vm._v(" "),_c(\'p\',[_vm._v("Una implementación que podemos diseñar, es la siguiente:")]),_vm._v(" "),_c(\'pre\',[_c(\'code\',{pre:true,attrs:{"class":"language-java"}},[_vm._v("    public class GpsCity {\\n\\n        //some fields data;\\n\\n        public void updateCity(City newCity)\\n        {\\n            city = newCity;\\n\\n            sHotel = new SystemHotel(city);\\n\\n            weather = new Weather(city);\\n\\n            featureNews = new News(city);\\n        }\\n\\n        public void visit(City newCity)\\n        {\\n            updateCity(newCity);\\n\\n            getDisplayWelcome();\\n\\n            getSystemHotel();\\n\\n            getWeather();\\n\\n            getFeatureNews();\\n\\n        }\\n\\n        //other methods..\\n    }\\n")])]),_vm._v(" "),_c(\'p\',[_vm._v("Los métodos "),_c(\'code\',{pre:true},[_vm._v("get")]),_vm._v(" obtienen información de sus respectivas entidades. No conocemos la implementación de las clases de las entidades, solo conocemos que es lo que hacen y como obtener la información pertinente.")]),_vm._v(" "),_c(\'p\',[_vm._v("El problema con esta primer versión radica en que, si deseamos añadir una nueva entidad, debemos reestructurar nuestra aplicación, por lo que se pierde flexibilidad.")]),_vm._v(" "),_c(\'p\',[_vm._v("Además, el código actual no nos permite modificar en tiempo de ejecución, que entidades queremos obtener. El sistema nos obliga a mostrar la información de todas las entidades sin poder realizar un filtrado.")]),_vm._v(" "),_c(\'p\',[_vm._v("Vemos que en el evento "),_c(\'code\',{pre:true},[_vm._v("updateCity()")]),_vm._v(", crea todas las entidades y asocia a cada una de ellas, la ciudad visitada actual. Como observamos, todas las entidades tienen una interfaz en común.")]),_vm._v(" "),_c(\'p\',[_vm._v("Es hora de poner en práctica el uso del "),_c(\'strong\',[_vm._v("patrón Observador (Observer Pattern)")]),_vm._v(" en nuestra aplicación.")]),_vm._v(" "),_c(\'h3\',[_vm._v("Definición del patrón observador")]),_vm._v(" "),_c(\'p\',[_vm._v("Cuando usted está tratando de imaginar el patrón de observador, un servicio de suscripción a un periódico con su editor y los suscriptores es una buena manera de visualizar el patrón. Sin embargo, en el mundo real, normalmente verás el patrón de observador definido de esta manera:")]),_vm._v(" "),_c(\'p\',[_vm._v("::: info")]),_vm._v(" "),_c(\'h4\',[_c(\'strong\',[_vm._v("Definición")])]),_vm._v(" "),_c(\'p\',[_c(\'strong\',[_vm._v("El patrón observador")]),_vm._v(" define una dependencia de uno a muchos entre los objetos, de modo que cuando un objeto cambia de estado, todos sus dependientes son notificados y actualizados automáticamente.\\n:::")]),_vm._v(" "),_c(\'p\',[_vm._v("Relacionemos esta definición con la forma en que hemos estado hablando sobre el patrón:")]),_vm._v(" "),_c(\'p\',[_vm._v("El sujeto y los observadores definen la relación uno a muchos. Los observadores dependen del tema, de modo que cuando el estado del sujeto cambia, los observadores reciben una notificación. Dependiendo del estilo de notificación, el observador también puede actualizarse con nuevos valores. Como descubrirá, hay algunas formas diferentes de implementar el patrón de observador, pero la mayoría gira en torno a un diseño de clase que incluye interfaces de sujeto y observador. Vamos a ver...")]),_vm._v(" "),_c(\'p\',[_c(\'img\',{attrs:{"src":"https://res.cloudinary.com/webxander/image/upload/v1545464516/patterns/ObserverDiagram.png","alt":"ObserverPattern"}})]),_vm._v(" "),_c(\'h3\',[_vm._v("El poder del bajo acoplamiento")]),_vm._v(" "),_c(\'p\',[_vm._v("Cuando dos objetos están ligeramente acoplados, pueden interactuar, pero tienen muy poco conocimiento el uno del otro. El Patrón observador proporciona un diseño de objeto donde los sujetos y los observadores están acoplados de manera flexible.")]),_vm._v(" "),_c(\'p\',[_vm._v("¿Por qué?")]),_vm._v(" "),_c(\'p\',[_vm._v("Lo único que el sujeto sabe sobre un observador es que implementa una determinada interfaz (la interfaz de observador). No necesita saber la clase concreta del observador, lo que hace, o cualquier otra cosa al respecto.")]),_vm._v(" "),_c(\'p\',[_vm._v("Podemos añadir nuevos observadores en cualquier momento. Debido a que el sujeto depende solo de una lista de objetos que implementan la interfaz de observador, podemos agregar observadores nuevos cuando queramos. De hecho, podemos reemplazar cualquier observador en tiempo de ejecución con otro observador y el sujeto seguirá funcionando. Asimismo, podemos eliminar observadores en cualquier momento.")]),_vm._v(" "),_c(\'p\',[_vm._v("Nunca necesitamos modificar al sujeto para agregar nuevos tipos de observadores. Digamos que tenemos una nueva clase concreta que debe ser un observador. No necesitamos realizar ningún cambio en al sujeto para adaptarse al nuevo tipo de clase, todo lo que tenemos que hacer es implementar la interfaz de observador en la nueva clase y registrarse como observador. Al sujeto no le importa; entregará notificaciones a cualquier objeto que implemente la interfaz de observador.")]),_vm._v(" "),_c(\'p\',[_vm._v("Podemos reutilizar sujetos u observadores independientemente unos de otros. Si tenemos otro uso para un sujeto o un observador, podemos reutilizarlos fácilmente porque los dos no están estrechamente acoplados. Los cambios en el sujeto o en un observador no afectarán al otro. Debido a que los dos están acoplados libremente, somos libres de realizar cambios en cualquiera de los dos, siempre y cuando los objetos sigan cumpliendo con sus obligaciones de implementar las interfaces del sujeto o del observador.")]),_vm._v(" "),_c(\'p\',[_vm._v("Los diseños poco acoplados nos permiten construir sistemas OO flexibles que pueden manejar el cambio porque minimizan la interdependencia entre los objetos.")]),_vm._v(" "),_c(\'h3\',[_vm._v("Diseñando la aplicación GPS City")]),_vm._v(" "),_c(\'p\',[_c(\'img\',{attrs:{"src":"https://res.cloudinary.com/webxander/image/upload/v1545464516/patterns/ObserverPattern-AppDiagram.jpg","alt":"ObserverPattern"}})]),_vm._v(" "),_c(\'p\',[_vm._v("Implementando la aplicación GPS City.")]),_vm._v(" "),_c(\'p\',[_vm._v("Vamos a comenzar nuestra implementación usando el diagrama de clases. Más adelante en este capítulo veremos que java proporciona algún soporte incorporado para el "),_c(\'strong\',[_vm._v("patrón Observer")]),_vm._v(", sin embargo, vamos a ensuciarnos las manos y escribir las nuestras por ahora. Mientras que en algunos casos puedes usar el soporte incorporado de Java, en muchos casos es más flexible construir el tuyo (y no es tan difícil). Entonces, comencemos con las interfaces:")]),_vm._v(" "),_c(\'pre\',[_c(\'code\',{pre:true,attrs:{"class":"language-java"}},[_vm._v("\\n\\n    public interface Observer {\\n\\n        public void update(City city);\\n    }\\n\\n")])]),_vm._v(" "),_c(\'p\',[_vm._v("La interfaz "),_c(\'code\',{pre:true},[_vm._v("Observer")]),_vm._v(" es implementada por todos los observadores, ellos tienen que implementar el método "),_c(\'code\',{pre:true},[_vm._v("update()")]),_vm._v(". Aquí le pasamos la ciudad actual a los observadores.")]),_vm._v(" "),_c(\'pre\',[_c(\'code\',{pre:true,attrs:{"class":"language-java"}},[_vm._v("        public interface Subject {\\n\\n            public void registerObserver(Observer o);\\n            public void unregisterObserver(Observer o);\\n\\n            public void notifyObserver();\\n\\n        }\\n")])]),_vm._v(" "),_c(\'p\',[_vm._v("Los métodos "),_c(\'code\',{pre:true},[_vm._v("registerObserver()")]),_vm._v(" y "),_c(\'code\',{pre:true},[_vm._v("unregisterObserver()")]),_vm._v(" obtienen un "),_c(\'code\',{pre:true},[_vm._v("Observer")]),_vm._v(" como argumento; que es el "),_c(\'code\',{pre:true},[_vm._v("Observer")]),_vm._v(" a ser registrado o eliminado.")]),_vm._v(" "),_c(\'p\',[_vm._v("El método "),_c(\'code\',{pre:true},[_vm._v("notifyObserver()")]),_vm._v(" es llamado para notificar a todos los observadores cuando el estado del sujeto ha sido cambiado.")]),_vm._v(" "),_c(\'pre\',[_c(\'code\',{pre:true,attrs:{"class":"language-java"}},[_vm._v("\\n        public interface DisplayElement {\\n\\n            public void display();\\n\\n        }\\n\\n")])]),_vm._v(" "),_c(\'p\',[_vm._v("Ahora vamos a implementar las clases correspondientes.")]),_vm._v(" "),_c(\'pre\',[_c(\'code\',{pre:true,attrs:{"class":"language-java"}},[_vm._v("\\n        public class GpsCity implements Subject{\\n\\n            private ArrayList observers;\\n\\n            public City city;\\n\\n            public GpsCity(){\\n                observers = new ArrayList();\\n            }\\n\\n            public void updateCity(City newCity){\\n\\n                city = newCity;\\n\\n            }\\n\\n            public void visit(City newCity)\\n            {\\n\\n                updateCity(newCity);\\n\\n                getDisplayWelcome();\\n\\n                notifyObserver();\\n\\n            }\\n\\n            public City getCity()\\n            {\\n                return city;\\n            }\\n\\n            public void getDisplayWelcome() {\\n                System.out.println(\\"Visitando... \\" + city.getName());\\n            }\\n\\n            @Override\\n            public void registerObserver(Observer o) {\\n                observers.add(o);\\n            }\\n\\n            @Override\\n            public void unregisterObserver(Observer o) {\\n\\n                int i = observers.indexOf(o);\\n                if (i>=0){\\n                    observers.remove(i);\\n                }\\n\\n            }\\n\\n            @Override\\n            public void notifyObserver() {\\n\\n                for(int i = 0; i < observers.size(); i++){\\n                    Observer observer = (Observer) observers.get(i);\\n                    observer.update(city);\\n                }\\n            }\\n        }\\n\\n")])]),_vm._v(" "),_c(\'p\',[_vm._v("En Java, para poder utilizar la clase "),_c(\'code\',{pre:true},[_vm._v("ArrayList")]),_vm._v(" debe importarla añadiendo en la cabecera "),_c(\'code\',{pre:true},[_vm._v("import java.util.ArrayList;")])]),_vm._v(" "),_c(\'pre\',[_c(\'code\',{pre:true,attrs:{"class":"language-java"}},[_vm._v("    public class City {\\n\\n        private String name;\\n\\n        public City(String newCityName)\\n        {\\n            name = newCityName;\\n        }\\n\\n        public String getName() {\\n            return name;\\n        }\\n\\n    }\\n")])]),_vm._v(" "),_c(\'pre\',[_c(\'code\',{pre:true,attrs:{"class":"language-java"}},[_vm._v("    public class News implements Observer, DisplayElement {\\n\\n        private City city;\\n\\n        public News(Subject gpsCity) {\\n\\n            gpsCity.registerObserver(this);\\n\\n        }\\n\\n        public void getFeaturedNews() {\\n            System.out.println(\\"Estas son las noticias descatadas para \\" + city.getName());\\n        }\\n\\n        @Override\\n        public void update(City city) {\\n            this.city = city;\\n            display();\\n        }\\n\\n        @Override\\n        public void display() {\\n            getFeaturedNews();\\n        }\\n\\n    }\\n\\n")])]),_vm._v(" "),_c(\'pre\',[_c(\'code\',{pre:true,attrs:{"class":"language-java"}},[_vm._v("    public class Weather implements Observer, DisplayElement {\\n\\n        private City city;\\n\\n        public Weather(Subject gpsCity)\\n        {\\n            gpsCity.registerObserver(this);\\n        }\\n\\n        public void show() {\\n            System.out.println(\\"Tiempo para la ciudad de \\" + city.getName());\\n        }\\n\\n        public void update(City city) {\\n            this.city = city;\\n            display();\\n        }\\n\\n        public void display() {\\n            show();\\n        }\\n\\n    }\\n\\n")])]),_vm._v(" "),_c(\'p\',[_vm._v("Ahora implementaremos un test para comprobar la funcionalidad de la aplicación.")]),_vm._v(" "),_c(\'pre\',[_c(\'code\',{pre:true,attrs:{"class":"language-java"}},[_vm._v("    public class GgsCityTest {\\n        public static void main(String[] args)\\n        {\\n            GpsCity gpscity = new GpsCity();\\n\\n            Weather weather = new Weather(gpscity);\\n            News news = new News(gpscity);\\n\\n            gpscity.visit(new City(\\"Mar del Plata\\"));\\n\\n            gpscity.visit(new City(\\"Tandil\\"));\\n\\n        }\\n    }\\n\\n")])]),_vm._v(" "),_c(\'p\',[_vm._v("Como podemos apreciar, cada vez que se ejecuta el método "),_c(\'code\',{pre:true},[_vm._v("visit()")]),_vm._v(", se dispara el evento "),_c(\'code\',{pre:true},[_vm._v("update()")]),_vm._v(" para que las diferentes entidades actualicen sus estados con la nueva ciudad ingresada. Veamos la salida en pantalla el resultado correspondiente.")]),_vm._v(" "),_c(\'p\',[_c(\'img\',{attrs:{"src":"https://res.cloudinary.com/webxander/image/upload/v1545464516/patterns/gpstext.png","alt":"ObserverPattern"}})])]) }]',component:{data:function(){return{templateRender:null}},render:function(e){return this.templateRender?this.templateRender():e("div","Rendering")},created:function(){this.templateRender=function(){var e=this.$createElement;this._self._c;return this._m(0)},this.$options.staticRenderFns=[function(){var e=this,n=e.$createElement,o=e._self._c||n;return o("div",{staticClass:"dynamicMarkdown"},[o("h2",[e._v("The Observer Pattern")]),e._v(" "),o("h3",[e._v("Introducción")]),e._v(" "),o("p",[e._v("En este capitulo, presentaremos otros de los patrones muy frecuentemente utilizado por los desarrolladores. El "),o("strong",[e._v("patrón Observer (Observador)")]),e._v(" permite notificar a los subscriptores si se han producido cambios en un objeto.")]),e._v(" "),o("h3",[e._v("GPS City Visit")]),e._v(" "),o("p",[e._v("Una agencia de turismo quiere proporcionar a los usuarios una aplicación GPS, para brindarle información sobre diferentes entidades de la ciudad. El visitante, desde un dispositivo colocado en su vehículo particular, debería ser informado automáticamente cada vez que visita una ciudad, sobre el clima local, los lugares de esparcimiento, las noticias más destacadas de la ciudad, entre otros factores.")]),e._v(" "),o("p",[e._v("Nos piden a nosotros, desarrollar la aplicación. Permitiendo añadir a futuro, nuevas entidades. Actualmente la agencia cuenta con información sobre el clima, las noticias destacadas de la ciudad y la oferta hotelera existente proveniente de una cadena muy reconocida.")]),e._v(" "),o("p",[e._v("Nosotros podríamos pensar en elaborar una clase como la siguiente:")]),e._v(" "),o("p",[o("img",{attrs:{src:"https://res.cloudinary.com/webxander/image/upload/v1545464516/patterns/ObserverPattern.jpg",alt:"ObserverPattern"}})]),e._v(" "),o("p",[e._v("Cada vez que la aplicación ingresa a una nueva ciudad, se invocaría al método "),o("code",{pre:!0},[e._v("visit()")]),e._v(" pasándole como parámetro la nueva ciudad. El método "),o("code",{pre:!0},[e._v("updateCity(City city);")]),e._v(" lo que hace es actualizar las diferentes entidades con la nueva ciudad.")]),e._v(" "),o("p",[e._v("Una implementación que podemos diseñar, es la siguiente:")]),e._v(" "),o("pre",[o("code",{pre:!0,attrs:{class:"language-java"}},[e._v("    public class GpsCity {\n\n        //some fields data;\n\n        public void updateCity(City newCity)\n        {\n            city = newCity;\n\n            sHotel = new SystemHotel(city);\n\n            weather = new Weather(city);\n\n            featureNews = new News(city);\n        }\n\n        public void visit(City newCity)\n        {\n            updateCity(newCity);\n\n            getDisplayWelcome();\n\n            getSystemHotel();\n\n            getWeather();\n\n            getFeatureNews();\n\n        }\n\n        //other methods..\n    }\n")])]),e._v(" "),o("p",[e._v("Los métodos "),o("code",{pre:!0},[e._v("get")]),e._v(" obtienen información de sus respectivas entidades. No conocemos la implementación de las clases de las entidades, solo conocemos que es lo que hacen y como obtener la información pertinente.")]),e._v(" "),o("p",[e._v("El problema con esta primer versión radica en que, si deseamos añadir una nueva entidad, debemos reestructurar nuestra aplicación, por lo que se pierde flexibilidad.")]),e._v(" "),o("p",[e._v("Además, el código actual no nos permite modificar en tiempo de ejecución, que entidades queremos obtener. El sistema nos obliga a mostrar la información de todas las entidades sin poder realizar un filtrado.")]),e._v(" "),o("p",[e._v("Vemos que en el evento "),o("code",{pre:!0},[e._v("updateCity()")]),e._v(", crea todas las entidades y asocia a cada una de ellas, la ciudad visitada actual. Como observamos, todas las entidades tienen una interfaz en común.")]),e._v(" "),o("p",[e._v("Es hora de poner en práctica el uso del "),o("strong",[e._v("patrón Observador (Observer Pattern)")]),e._v(" en nuestra aplicación.")]),e._v(" "),o("h3",[e._v("Definición del patrón observador")]),e._v(" "),o("p",[e._v("Cuando usted está tratando de imaginar el patrón de observador, un servicio de suscripción a un periódico con su editor y los suscriptores es una buena manera de visualizar el patrón. Sin embargo, en el mundo real, normalmente verás el patrón de observador definido de esta manera:")]),e._v(" "),o("p",[e._v("::: info")]),e._v(" "),o("h4",[o("strong",[e._v("Definición")])]),e._v(" "),o("p",[o("strong",[e._v("El patrón observador")]),e._v(" define una dependencia de uno a muchos entre los objetos, de modo que cuando un objeto cambia de estado, todos sus dependientes son notificados y actualizados automáticamente.\n:::")]),e._v(" "),o("p",[e._v("Relacionemos esta definición con la forma en que hemos estado hablando sobre el patrón:")]),e._v(" "),o("p",[e._v("El sujeto y los observadores definen la relación uno a muchos. Los observadores dependen del tema, de modo que cuando el estado del sujeto cambia, los observadores reciben una notificación. Dependiendo del estilo de notificación, el observador también puede actualizarse con nuevos valores. Como descubrirá, hay algunas formas diferentes de implementar el patrón de observador, pero la mayoría gira en torno a un diseño de clase que incluye interfaces de sujeto y observador. Vamos a ver...")]),e._v(" "),o("p",[o("img",{attrs:{src:"https://res.cloudinary.com/webxander/image/upload/v1545464516/patterns/ObserverDiagram.png",alt:"ObserverPattern"}})]),e._v(" "),o("h3",[e._v("El poder del bajo acoplamiento")]),e._v(" "),o("p",[e._v("Cuando dos objetos están ligeramente acoplados, pueden interactuar, pero tienen muy poco conocimiento el uno del otro. El Patrón observador proporciona un diseño de objeto donde los sujetos y los observadores están acoplados de manera flexible.")]),e._v(" "),o("p",[e._v("¿Por qué?")]),e._v(" "),o("p",[e._v("Lo único que el sujeto sabe sobre un observador es que implementa una determinada interfaz (la interfaz de observador). No necesita saber la clase concreta del observador, lo que hace, o cualquier otra cosa al respecto.")]),e._v(" "),o("p",[e._v("Podemos añadir nuevos observadores en cualquier momento. Debido a que el sujeto depende solo de una lista de objetos que implementan la interfaz de observador, podemos agregar observadores nuevos cuando queramos. De hecho, podemos reemplazar cualquier observador en tiempo de ejecución con otro observador y el sujeto seguirá funcionando. Asimismo, podemos eliminar observadores en cualquier momento.")]),e._v(" "),o("p",[e._v("Nunca necesitamos modificar al sujeto para agregar nuevos tipos de observadores. Digamos que tenemos una nueva clase concreta que debe ser un observador. No necesitamos realizar ningún cambio en al sujeto para adaptarse al nuevo tipo de clase, todo lo que tenemos que hacer es implementar la interfaz de observador en la nueva clase y registrarse como observador. Al sujeto no le importa; entregará notificaciones a cualquier objeto que implemente la interfaz de observador.")]),e._v(" "),o("p",[e._v("Podemos reutilizar sujetos u observadores independientemente unos de otros. Si tenemos otro uso para un sujeto o un observador, podemos reutilizarlos fácilmente porque los dos no están estrechamente acoplados. Los cambios en el sujeto o en un observador no afectarán al otro. Debido a que los dos están acoplados libremente, somos libres de realizar cambios en cualquiera de los dos, siempre y cuando los objetos sigan cumpliendo con sus obligaciones de implementar las interfaces del sujeto o del observador.")]),e._v(" "),o("p",[e._v("Los diseños poco acoplados nos permiten construir sistemas OO flexibles que pueden manejar el cambio porque minimizan la interdependencia entre los objetos.")]),e._v(" "),o("h3",[e._v("Diseñando la aplicación GPS City")]),e._v(" "),o("p",[o("img",{attrs:{src:"https://res.cloudinary.com/webxander/image/upload/v1545464516/patterns/ObserverPattern-AppDiagram.jpg",alt:"ObserverPattern"}})]),e._v(" "),o("p",[e._v("Implementando la aplicación GPS City.")]),e._v(" "),o("p",[e._v("Vamos a comenzar nuestra implementación usando el diagrama de clases. Más adelante en este capítulo veremos que java proporciona algún soporte incorporado para el "),o("strong",[e._v("patrón Observer")]),e._v(", sin embargo, vamos a ensuciarnos las manos y escribir las nuestras por ahora. Mientras que en algunos casos puedes usar el soporte incorporado de Java, en muchos casos es más flexible construir el tuyo (y no es tan difícil). Entonces, comencemos con las interfaces:")]),e._v(" "),o("pre",[o("code",{pre:!0,attrs:{class:"language-java"}},[e._v("\n\n    public interface Observer {\n\n        public void update(City city);\n    }\n\n")])]),e._v(" "),o("p",[e._v("La interfaz "),o("code",{pre:!0},[e._v("Observer")]),e._v(" es implementada por todos los observadores, ellos tienen que implementar el método "),o("code",{pre:!0},[e._v("update()")]),e._v(". Aquí le pasamos la ciudad actual a los observadores.")]),e._v(" "),o("pre",[o("code",{pre:!0,attrs:{class:"language-java"}},[e._v("        public interface Subject {\n\n            public void registerObserver(Observer o);\n            public void unregisterObserver(Observer o);\n\n            public void notifyObserver();\n\n        }\n")])]),e._v(" "),o("p",[e._v("Los métodos "),o("code",{pre:!0},[e._v("registerObserver()")]),e._v(" y "),o("code",{pre:!0},[e._v("unregisterObserver()")]),e._v(" obtienen un "),o("code",{pre:!0},[e._v("Observer")]),e._v(" como argumento; que es el "),o("code",{pre:!0},[e._v("Observer")]),e._v(" a ser registrado o eliminado.")]),e._v(" "),o("p",[e._v("El método "),o("code",{pre:!0},[e._v("notifyObserver()")]),e._v(" es llamado para notificar a todos los observadores cuando el estado del sujeto ha sido cambiado.")]),e._v(" "),o("pre",[o("code",{pre:!0,attrs:{class:"language-java"}},[e._v("\n        public interface DisplayElement {\n\n            public void display();\n\n        }\n\n")])]),e._v(" "),o("p",[e._v("Ahora vamos a implementar las clases correspondientes.")]),e._v(" "),o("pre",[o("code",{pre:!0,attrs:{class:"language-java"}},[e._v('\n        public class GpsCity implements Subject{\n\n            private ArrayList observers;\n\n            public City city;\n\n            public GpsCity(){\n                observers = new ArrayList();\n            }\n\n            public void updateCity(City newCity){\n\n                city = newCity;\n\n            }\n\n            public void visit(City newCity)\n            {\n\n                updateCity(newCity);\n\n                getDisplayWelcome();\n\n                notifyObserver();\n\n            }\n\n            public City getCity()\n            {\n                return city;\n            }\n\n            public void getDisplayWelcome() {\n                System.out.println("Visitando... " + city.getName());\n            }\n\n            @Override\n            public void registerObserver(Observer o) {\n                observers.add(o);\n            }\n\n            @Override\n            public void unregisterObserver(Observer o) {\n\n                int i = observers.indexOf(o);\n                if (i>=0){\n                    observers.remove(i);\n                }\n\n            }\n\n            @Override\n            public void notifyObserver() {\n\n                for(int i = 0; i < observers.size(); i++){\n                    Observer observer = (Observer) observers.get(i);\n                    observer.update(city);\n                }\n            }\n        }\n\n')])]),e._v(" "),o("p",[e._v("En Java, para poder utilizar la clase "),o("code",{pre:!0},[e._v("ArrayList")]),e._v(" debe importarla añadiendo en la cabecera "),o("code",{pre:!0},[e._v("import java.util.ArrayList;")])]),e._v(" "),o("pre",[o("code",{pre:!0,attrs:{class:"language-java"}},[e._v("    public class City {\n\n        private String name;\n\n        public City(String newCityName)\n        {\n            name = newCityName;\n        }\n\n        public String getName() {\n            return name;\n        }\n\n    }\n")])]),e._v(" "),o("pre",[o("code",{pre:!0,attrs:{class:"language-java"}},[e._v('    public class News implements Observer, DisplayElement {\n\n        private City city;\n\n        public News(Subject gpsCity) {\n\n            gpsCity.registerObserver(this);\n\n        }\n\n        public void getFeaturedNews() {\n            System.out.println("Estas son las noticias descatadas para " + city.getName());\n        }\n\n        @Override\n        public void update(City city) {\n            this.city = city;\n            display();\n        }\n\n        @Override\n        public void display() {\n            getFeaturedNews();\n        }\n\n    }\n\n')])]),e._v(" "),o("pre",[o("code",{pre:!0,attrs:{class:"language-java"}},[e._v('    public class Weather implements Observer, DisplayElement {\n\n        private City city;\n\n        public Weather(Subject gpsCity)\n        {\n            gpsCity.registerObserver(this);\n        }\n\n        public void show() {\n            System.out.println("Tiempo para la ciudad de " + city.getName());\n        }\n\n        public void update(City city) {\n            this.city = city;\n            display();\n        }\n\n        public void display() {\n            show();\n        }\n\n    }\n\n')])]),e._v(" "),o("p",[e._v("Ahora implementaremos un test para comprobar la funcionalidad de la aplicación.")]),e._v(" "),o("pre",[o("code",{pre:!0,attrs:{class:"language-java"}},[e._v('    public class GgsCityTest {\n        public static void main(String[] args)\n        {\n            GpsCity gpscity = new GpsCity();\n\n            Weather weather = new Weather(gpscity);\n            News news = new News(gpscity);\n\n            gpscity.visit(new City("Mar del Plata"));\n\n            gpscity.visit(new City("Tandil"));\n\n        }\n    }\n\n')])]),e._v(" "),o("p",[e._v("Como podemos apreciar, cada vez que se ejecuta el método "),o("code",{pre:!0},[e._v("visit()")]),e._v(", se dispara el evento "),o("code",{pre:!0},[e._v("update()")]),e._v(" para que las diferentes entidades actualicen sus estados con la nueva ciudad ingresada. Veamos la salida en pantalla el resultado correspondiente.")]),e._v(" "),o("p",[o("img",{attrs:{src:"https://res.cloudinary.com/webxander/image/upload/v1545464516/patterns/gpstext.png",alt:"ObserverPattern"}})])])}]}}}}}}]);