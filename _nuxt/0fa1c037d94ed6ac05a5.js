(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{392:function(e,o){e.exports={body:'## The Strategy Pattern\n\n### Primeros pasos\n\nNos contratan para desarrollar una aplicaci&oacute;n que gestione animales de un zool&oacute;gico. Como sabemos, en un zoo existen diferentes tipos de animales. Por este motivo, inicialmente los dise&ntilde;adores del sistema han creado una superclase llamada &nbsp; `Animal`, la cual todos los tipos de animales heredan de ella.\n\n![PatronesStrategy](https://res.cloudinary.com/webxander/image/upload/v1545464516/patterns/PatronesStrategy.png)\n\n::: info\n\n#### Observaciones\n\nTodos los animales deben poder emitir un sonido, tambi&eacute;n deben poder comer, entre otras acciones comunes.\nCada subtipo de animal, es responsable de implementar el m&eacute;todo `display()` para determinar de que manera ser&aacute; visualizado en pantalla.\nEl m&eacute;todo `display()` es abstracto, todos los subtipos de animal, lucen de manera diferente.\n:::\n\nEn el ultimo a&ntilde;o, el gerente del zool&oacute;gico ha querido comprobar que animales pueden volar y cu&aacute;les no. El problema aqu&iacute;, radica en que no todos los animales tienen pueden volar, por ejemplo, un perro o un gato no vuela, pero un pajaro, si lo hace.\n\nEl primer dise&ntilde;o que se nos ocurre implementar, es el siguiente:\n\n![PatronesStrategy2](https://res.cloudinary.com/webxander/image/upload/v1545464516/patterns/PatronesStrategy2.png)\n\nPerfecto, este dise&ntilde;o a&ntilde;ade una funci&oacute;n a la superclase `Animal`, llamada `fly()`&nbsp;y en los subtipos de animales que no puedan volar, se sobrescribe el m&eacute;todo retornando un valor nulo.\n\nAqu&iacute; existe varios inconvenientes. El c&oacute;digo es duplicado en las subclases. Por otra parte, es dif&iacute;cil conocer los comportamientos de todos los animales. Adem&aacute;s, cada vez que se decida a&ntilde;adir un nuevo tipo de animal, ya sea porque el zool&oacute;gico va creciendo a lo largo del tiempo, se necesita sobrescribir los m&eacute;todos en los diferentes tipos de ejemplares. Adem&aacute;s, si la aplicaci&oacute;n desea tambi&eacute;n comprobar que animales pueden nadar, debemos hacer exactamente lo mismo en cada uno de los animales que no lo pueden hacer, por lo que el c&oacute;digo se hace dif&iacute;cil de mantener.\n\n### Separando los comportamientos variables de los comunes\n\n&iquest;Por d&oacute;nde empezamos? Como hemos dicho, existen comportamientos que todos los animales tienen, por ejemplo, el de comer, emitir sonido, caminar, entre otros, y comportamientos que solo una clase de animales poseen, como nadar o volar.\n\nDicho esto, dejemos solo en la clase `Animal`, aquellos comportamientos que no deber&iacute;an cambiar. Solo vamos a separar aquellas partes que cambian. Para ello, vamos a crear un conjunto de clases fuera de la clase `Animal`. Cada conjunto de clase, contendr&aacute; todas las implementaciones de sus respectivos comportamientos. Por ejemplo, nosotros podr&iacute;amos tener una clase que implemente swinning, otra que implemente running, otra que implemente flying.\n\nComo sabemos, las partes de la clase `Animal`&nbsp;que cambian, es `fly()`. Para separar este comportamiento, lo que haremos ser&aacute; extraer este m&eacute;todo y crear un nuevo conjunto de clases para representar esta acci&oacute;n.\n\n### Dise&ntilde;ando los comportamientos de la clase Animal\n\nEntonces, &iquest;c&oacute;mo vamos a dise&ntilde;ar el conjunto de clases que implementan los comportamientos fly? Nos gustar&iacute;a mantener las cosas flexibles; despu&eacute;s de todo, fue la inflexibilidad en los comportamientos de los animales lo que nos meti&oacute; en problemas en primer lugar. Y sabemos que queremos asignar comportamientos a las instancias de Animal. Por ejemplo, podr&iacute;amos instanciar una nueva instancia de Butterfly e inicializarla con un tipo espec&iacute;fico de comportamiento de vuelo. Y mientras estamos all&iacute;, &iquest;por qu&eacute; no nos aseguramos de que podamos cambiar el comportamiento de un animal din&aacute;micamente? En otras palabras, deber&iacute;amos incluir m&eacute;todos de establecimiento de comportamiento en las clases de Animal para que podamos, por ejemplo, cambiar el comportamiento de vuelo de Butterfly o Mariposa en tiempo de ejecuci&oacute;n. Dados estos objetivos, veamos nuestro segundo principio de dise&ntilde;o: utilizaremos una interfaz para representar cada comportamiento, por ejemplo, `FlyBehavior`, y cada implementaci&oacute;n de un comportamiento implementar&aacute; una de esas interfaces. Haremos un conjunto de clases cuya raz&oacute;n de existir, sea representar un comportamiento (por ejemplo, &quot;flying&quot;), y es la clase del comportamiento, en lugar de la clase Animal, la que implementar&aacute; la interfaz del comportamiento. Esto est&aacute; en contraste con la forma en que hac&iacute;amos las cosas antes, donde un comportamiento proven&iacute;a de una implementaci&oacute;n concreta en la superclase Animal, o al proporcionar una implementaci&oacute;n especializada en la subclase misma. En ambos casos confiamos en una implementaci&oacute;n. Est&aacute;bamos atrapados en el uso de esa implementaci&oacute;n espec&iacute;fica y no hab&iacute;a lugar para cambiar el comportamiento (que no sea escribir m&aacute;s c&oacute;digo). Con nuestro nuevo dise&ntilde;o, las subclases de Animal usar&aacute;n un comportamiento representado por una interfaz (`FlyBehavior`), de modo que la implementaci&oacute;n real del comportamiento (en otras palabras, el comportamiento concreto espec&iacute;fico codificado en la clase que implementa `FlyBehavior`) no estar&aacute; bloqueado en la subclase de Animal.\n\n![Patrones-Strategy-Page-2](https://res.cloudinary.com/webxander/image/upload/v1545464516/patterns/Patrones-Strategy-Page-2.jpg)\n\nLa clase `IfFlys` que implementa la interfaz `FlyBehavior` ser&aacute; usada por todos los animales que puedan volar, en cambio, la clase `CantFly`, ser&aacute; usada por los animales que no puedan volar.\n\nCon este dise&ntilde;o, otros tipos de objetos pueden reutilizar nuestros comportamientos de vuelo porque &eacute;stos ya no est&aacute;n ocultos en nuestra clase `Animal`.\n\nTambi&eacute;n podemos agregar nuevos comportamientos sin modificar ninguna de sus clases de comportamiento existentes ni tocar ninguna de las clases de `Animal` que usan comportamientos de vuelo.\n\n### Integrando la interfaz FlyBehavior\n\nLa clave es que un animal ahora delegar&aacute; su comportamiento de vuelo, en lugar de usar m&eacute;todos de vuelo definidos en la clase (o subclase) de animal.\n\nPrimero agregaremos un atributo a la clase `Animal` llamada`flyBehavior` que est&aacute; declarada como interfaz). Cada objeto de animal configurar&aacute; esta variable polim&oacute;rficamente para hacer referencia al tipo de comportamiento espec&iacute;fico que desear&iacute;a en el tiempo de ejecuci&oacute;n. Tambi&eacute;n eliminaremos el m&eacute;todo `fly()` de la clase Animal (y de cualquier subclase) porque hemos trasladado este comportamiento a la clase `FlyBehavior`. Reemplazaremos `fly()` en la clase Animal con un m&eacute;todo similar, llamado `tryToFly()`; Ver&aacute;s c&oacute;mo funcionan a continuaci&oacute;n.\n\n![Patrones-Strategy-Page-3](https://res.cloudinary.com/webxander/image/upload/v1545464516/patterns/Patrones-Strategy-Page-3.jpg)\n\nAhora implementamos el m&eacute;todo `tryToFly()`\n\n```java\n        public class Animal {\n\n            FlyBehavior flyBehavior\n\n            public void tryToFly()\n            {\n                flyBehavior.fly();\n            }\n       }\n```\n\nBastante simple. Ahora como vemos, un animal solo permite que el objeto al que es referenciado `flyBehavior` pueda comprobar si este vuela o no. En esta parte del c&oacute;digo no nos importa qu&eacute; tipo de objeto es, lo &uacute;nico que nos importa es que sepa c&oacute;mo vuela, si es que lo hace. De acuerdo, es hora de aprender a utilizar las variables de instancia `flyBehavior`. Echemos un vistazo a la clase `Bird`\n\n```java\n    public class Bird extends Animal {\n\n        public Bird()\n        {\n            flyBehavior = new ItsFlys();\n        }\n\n        @Override\n        public void display() {\n            System.out.println("I\'m a Bird!!");\n        }\n\n        public void makeSound()\n        {\n            System.out.println("I\'m a Bird,\n                I can make a cuack!");\n        }\n}\n```\n\nComo observamos, en el constructor de la clase `Bird`, asignamos una nueva instancia de la clase `ItsFly` y la guardamos en el atributo `flyBehavior`. Esto quiere decir que, un objeto `Bird` tiene la capacidad de poder volar, pero si se tratase de un `Dog`, la instancia asignada en el atributo `flyBehavior` ser&iacute;a `CantFly()`.\n\n### Testeando nuestra primera aplicaci&oacute;n\n\nVamos a implementar la clase Animal y sus respectivos tipos de animales, (`Bird` y `Dog`), tambi&eacute;n crearemos la interfaz `FlyBehavior` y sus conjuntos de clases que implementan esta interfaz.\n\n```java\n    public abstract class Animal {\n\n            FlyBehavior flyBehavior;\n\n            public Animal(){\n\n            }\n\n            public abstract void display();\n\n            public void makeSound()\n            {\n                System.out.println("I\'m a Animal, I can make a sound");\n            }\n\n            public void eat()\n            {\n                System.out.println("I\'m a Animal, I can eat a food");\n            }\n\n            public void tryToFly()\n            {\n                flyBehavior.fly();\n            }\n\n        }\n```\n\n```java\n    public class Bird extends Animal {\n\n            public Bird()\n            {\n                flyBehavior = new ItsFlys();\n            }\n\n            @Override\n            public void display() {\n                System.out.println("I\'m a Bird!!");\n            }\n\n            public void makeSound()\n            {\n                System.out.println("I\'m a Bird, I can make a cuack!");\n            }\n\n}\n```\n\n```java\n    public class Dog extends Animal {\n\n            public Dog()\n            {\n                flyBehavior = new CantFly();\n            }\n\n            @Override\n            public void display() {\n                System.out.println("I\'m a Dog!!");\n            }\n\n            public void makeSound()\n            {\n                System.out.println("I\'m a Dog, I can make a guau!");\n            }\n\n        }\n```\n\n```java\n    public interface FlyBehavior {\n\n        public void fly();\n    }\n```\n\n```java\n\n    public class ItsFlys implements FlyBehavior {\n\n        @Override\n        public void fly() {\n            System.out.println("I can fly!");\n        }\n\n    }\n```\n\n```java\n    public class CantFly implements FlyBehavior {\n\n        @Override\n        public void fly() {\n            System.out.println("I can\'t fly...");\n        }\n\n    }\n```\n\nAhora vamos a crear un mini test para verificar la funcionalidad de las mismas.\n\n```java\n    public class ZooTest {\n            public static void main(String[] args)\n            {\n                Animal tweety = new Bird();\n\n                tweety.tryToFly();\n\n                tweety.display();\n\n                Animal snoopy = new Dog();\n\n                snoopy.tryToFly();\n\n                snoopy.display();\n\n            }\n        }\n```\n\nPerfecto, ejecutamos dicho test y veremos en la consola de nuestro IDE el siguiente resultado:\n\n![zootest](https://res.cloudinary.com/webxander/image/upload/v1545464516/patterns/zootest.png)\n\n### A&ntilde;adiendo comportamientos din&aacute;micamente\n\nAhora podemos crear en la clase Animal, funciones miembros para cambiar din&aacute;micamente dichos comportamientos. Es decir, en tiempo de ejecuci&oacute;n, podemos decirle a un objeto `Bird` que no puede volar.\n\n```java\n    public void setFlyingAbility(FlyBehavior newFlyBehavior){\n        flyBehavior = newFlyBehavior;\n    }\n```\n\nModificamos nuestro test a&ntilde;adiendo las siguientes l&iacute;neas:\n\n```java\n...\n tweety.setFlyingAbility(new CantFly());\n        tweety.display();\n        tweety.tryToFly();\n...\n```\n\nEjecutamos nuevamente el programa.\n\n![zootest2](https://res.cloudinary.com/webxander/image/upload/v1545464516/patterns/zootest2.png)\n\nHasta aqu&iacute;, hemos visto como este patr&oacute;n, define una familia de algoritmos, encapsula cada uno y los hace intercambiables.\n\n::: info\n**The Strategy Pattern** permite que el algoritmo var&iacute;e dependiendo de los clientes que lo utilizan.\n:::\n',html:'<h2>The Strategy Pattern</h2>\n<h3>Primeros pasos</h3>\n<p>Nos contratan para desarrollar una aplicación que gestione animales de un zoológico. Como sabemos, en un zoo existen diferentes tipos de animales. Por este motivo, inicialmente los diseñadores del sistema han creado una superclase llamada   <code>Animal</code>, la cual todos los tipos de animales heredan de ella.</p>\n<p><img src="https://res.cloudinary.com/webxander/image/upload/v1545464516/patterns/PatronesStrategy.png" alt="PatronesStrategy"></p>\n<p>::: info</p>\n<h4>Observaciones</h4>\n<p>Todos los animales deben poder emitir un sonido, también deben poder comer, entre otras acciones comunes.\nCada subtipo de animal, es responsable de implementar el método <code>display()</code> para determinar de que manera será visualizado en pantalla.\nEl método <code>display()</code> es abstracto, todos los subtipos de animal, lucen de manera diferente.\n:::</p>\n<p>En el ultimo año, el gerente del zoológico ha querido comprobar que animales pueden volar y cuáles no. El problema aquí, radica en que no todos los animales tienen pueden volar, por ejemplo, un perro o un gato no vuela, pero un pajaro, si lo hace.</p>\n<p>El primer diseño que se nos ocurre implementar, es el siguiente:</p>\n<p><img src="https://res.cloudinary.com/webxander/image/upload/v1545464516/patterns/PatronesStrategy2.png" alt="PatronesStrategy2"></p>\n<p>Perfecto, este diseño añade una función a la superclase <code>Animal</code>, llamada <code>fly()</code> y en los subtipos de animales que no puedan volar, se sobrescribe el método retornando un valor nulo.</p>\n<p>Aquí existe varios inconvenientes. El código es duplicado en las subclases. Por otra parte, es difícil conocer los comportamientos de todos los animales. Además, cada vez que se decida añadir un nuevo tipo de animal, ya sea porque el zoológico va creciendo a lo largo del tiempo, se necesita sobrescribir los métodos en los diferentes tipos de ejemplares. Además, si la aplicación desea también comprobar que animales pueden nadar, debemos hacer exactamente lo mismo en cada uno de los animales que no lo pueden hacer, por lo que el código se hace difícil de mantener.</p>\n<h3>Separando los comportamientos variables de los comunes</h3>\n<p>¿Por dónde empezamos? Como hemos dicho, existen comportamientos que todos los animales tienen, por ejemplo, el de comer, emitir sonido, caminar, entre otros, y comportamientos que solo una clase de animales poseen, como nadar o volar.</p>\n<p>Dicho esto, dejemos solo en la clase <code>Animal</code>, aquellos comportamientos que no deberían cambiar. Solo vamos a separar aquellas partes que cambian. Para ello, vamos a crear un conjunto de clases fuera de la clase <code>Animal</code>. Cada conjunto de clase, contendrá todas las implementaciones de sus respectivos comportamientos. Por ejemplo, nosotros podríamos tener una clase que implemente swinning, otra que implemente running, otra que implemente flying.</p>\n<p>Como sabemos, las partes de la clase <code>Animal</code> que cambian, es <code>fly()</code>. Para separar este comportamiento, lo que haremos será extraer este método y crear un nuevo conjunto de clases para representar esta acción.</p>\n<h3>Diseñando los comportamientos de la clase Animal</h3>\n<p>Entonces, ¿cómo vamos a diseñar el conjunto de clases que implementan los comportamientos fly? Nos gustaría mantener las cosas flexibles; después de todo, fue la inflexibilidad en los comportamientos de los animales lo que nos metió en problemas en primer lugar. Y sabemos que queremos asignar comportamientos a las instancias de Animal. Por ejemplo, podríamos instanciar una nueva instancia de Butterfly e inicializarla con un tipo específico de comportamiento de vuelo. Y mientras estamos allí, ¿por qué no nos aseguramos de que podamos cambiar el comportamiento de un animal dinámicamente? En otras palabras, deberíamos incluir métodos de establecimiento de comportamiento en las clases de Animal para que podamos, por ejemplo, cambiar el comportamiento de vuelo de Butterfly o Mariposa en tiempo de ejecución. Dados estos objetivos, veamos nuestro segundo principio de diseño: utilizaremos una interfaz para representar cada comportamiento, por ejemplo, <code>FlyBehavior</code>, y cada implementación de un comportamiento implementará una de esas interfaces. Haremos un conjunto de clases cuya razón de existir, sea representar un comportamiento (por ejemplo, &quot;flying&quot;), y es la clase del comportamiento, en lugar de la clase Animal, la que implementará la interfaz del comportamiento. Esto está en contraste con la forma en que hacíamos las cosas antes, donde un comportamiento provenía de una implementación concreta en la superclase Animal, o al proporcionar una implementación especializada en la subclase misma. En ambos casos confiamos en una implementación. Estábamos atrapados en el uso de esa implementación específica y no había lugar para cambiar el comportamiento (que no sea escribir más código). Con nuestro nuevo diseño, las subclases de Animal usarán un comportamiento representado por una interfaz (<code>FlyBehavior</code>), de modo que la implementación real del comportamiento (en otras palabras, el comportamiento concreto específico codificado en la clase que implementa <code>FlyBehavior</code>) no estará bloqueado en la subclase de Animal.</p>\n<p><img src="https://res.cloudinary.com/webxander/image/upload/v1545464516/patterns/Patrones-Strategy-Page-2.jpg" alt="Patrones-Strategy-Page-2"></p>\n<p>La clase <code>IfFlys</code> que implementa la interfaz <code>FlyBehavior</code> será usada por todos los animales que puedan volar, en cambio, la clase <code>CantFly</code>, será usada por los animales que no puedan volar.</p>\n<p>Con este diseño, otros tipos de objetos pueden reutilizar nuestros comportamientos de vuelo porque éstos ya no están ocultos en nuestra clase <code>Animal</code>.</p>\n<p>También podemos agregar nuevos comportamientos sin modificar ninguna de sus clases de comportamiento existentes ni tocar ninguna de las clases de <code>Animal</code> que usan comportamientos de vuelo.</p>\n<h3>Integrando la interfaz FlyBehavior</h3>\n<p>La clave es que un animal ahora delegará su comportamiento de vuelo, en lugar de usar métodos de vuelo definidos en la clase (o subclase) de animal.</p>\n<p>Primero agregaremos un atributo a la clase <code>Animal</code> llamada<code>flyBehavior</code> que está declarada como interfaz). Cada objeto de animal configurará esta variable polimórficamente para hacer referencia al tipo de comportamiento específico que desearía en el tiempo de ejecución. También eliminaremos el método <code>fly()</code> de la clase Animal (y de cualquier subclase) porque hemos trasladado este comportamiento a la clase <code>FlyBehavior</code>. Reemplazaremos <code>fly()</code> en la clase Animal con un método similar, llamado <code>tryToFly()</code>; Verás cómo funcionan a continuación.</p>\n<p><img src="https://res.cloudinary.com/webxander/image/upload/v1545464516/patterns/Patrones-Strategy-Page-3.jpg" alt="Patrones-Strategy-Page-3"></p>\n<p>Ahora implementamos el método <code>tryToFly()</code></p>\n<pre><code class="language-java">        public class Animal {\n\n            FlyBehavior flyBehavior\n\n            public void tryToFly()\n            {\n                flyBehavior.fly();\n            }\n       }\n</code></pre>\n<p>Bastante simple. Ahora como vemos, un animal solo permite que el objeto al que es referenciado <code>flyBehavior</code> pueda comprobar si este vuela o no. En esta parte del código no nos importa qué tipo de objeto es, lo único que nos importa es que sepa cómo vuela, si es que lo hace. De acuerdo, es hora de aprender a utilizar las variables de instancia <code>flyBehavior</code>. Echemos un vistazo a la clase <code>Bird</code></p>\n<pre><code class="language-java">    public class Bird extends Animal {\n\n        public Bird()\n        {\n            flyBehavior = new ItsFlys();\n        }\n\n        @Override\n        public void display() {\n            System.out.println(&quot;I\'m a Bird!!&quot;);\n        }\n\n        public void makeSound()\n        {\n            System.out.println(&quot;I\'m a Bird,\n                I can make a cuack!&quot;);\n        }\n}\n</code></pre>\n<p>Como observamos, en el constructor de la clase <code>Bird</code>, asignamos una nueva instancia de la clase <code>ItsFly</code> y la guardamos en el atributo <code>flyBehavior</code>. Esto quiere decir que, un objeto <code>Bird</code> tiene la capacidad de poder volar, pero si se tratase de un <code>Dog</code>, la instancia asignada en el atributo <code>flyBehavior</code> sería <code>CantFly()</code>.</p>\n<h3>Testeando nuestra primera aplicación</h3>\n<p>Vamos a implementar la clase Animal y sus respectivos tipos de animales, (<code>Bird</code> y <code>Dog</code>), también crearemos la interfaz <code>FlyBehavior</code> y sus conjuntos de clases que implementan esta interfaz.</p>\n<pre><code class="language-java">    public abstract class Animal {\n\n            FlyBehavior flyBehavior;\n\n            public Animal(){\n\n            }\n\n            public abstract void display();\n\n            public void makeSound()\n            {\n                System.out.println(&quot;I\'m a Animal, I can make a sound&quot;);\n            }\n\n            public void eat()\n            {\n                System.out.println(&quot;I\'m a Animal, I can eat a food&quot;);\n            }\n\n            public void tryToFly()\n            {\n                flyBehavior.fly();\n            }\n\n        }\n</code></pre>\n<pre><code class="language-java">    public class Bird extends Animal {\n\n            public Bird()\n            {\n                flyBehavior = new ItsFlys();\n            }\n\n            @Override\n            public void display() {\n                System.out.println(&quot;I\'m a Bird!!&quot;);\n            }\n\n            public void makeSound()\n            {\n                System.out.println(&quot;I\'m a Bird, I can make a cuack!&quot;);\n            }\n\n}\n</code></pre>\n<pre><code class="language-java">    public class Dog extends Animal {\n\n            public Dog()\n            {\n                flyBehavior = new CantFly();\n            }\n\n            @Override\n            public void display() {\n                System.out.println(&quot;I\'m a Dog!!&quot;);\n            }\n\n            public void makeSound()\n            {\n                System.out.println(&quot;I\'m a Dog, I can make a guau!&quot;);\n            }\n\n        }\n</code></pre>\n<pre><code class="language-java">    public interface FlyBehavior {\n\n        public void fly();\n    }\n</code></pre>\n<pre><code class="language-java">\n    public class ItsFlys implements FlyBehavior {\n\n        @Override\n        public void fly() {\n            System.out.println(&quot;I can fly!&quot;);\n        }\n\n    }\n</code></pre>\n<pre><code class="language-java">    public class CantFly implements FlyBehavior {\n\n        @Override\n        public void fly() {\n            System.out.println(&quot;I can\'t fly...&quot;);\n        }\n\n    }\n</code></pre>\n<p>Ahora vamos a crear un mini test para verificar la funcionalidad de las mismas.</p>\n<pre><code class="language-java">    public class ZooTest {\n            public static void main(String[] args)\n            {\n                Animal tweety = new Bird();\n\n                tweety.tryToFly();\n\n                tweety.display();\n\n                Animal snoopy = new Dog();\n\n                snoopy.tryToFly();\n\n                snoopy.display();\n\n            }\n        }\n</code></pre>\n<p>Perfecto, ejecutamos dicho test y veremos en la consola de nuestro IDE el siguiente resultado:</p>\n<p><img src="https://res.cloudinary.com/webxander/image/upload/v1545464516/patterns/zootest.png" alt="zootest"></p>\n<h3>Añadiendo comportamientos dinámicamente</h3>\n<p>Ahora podemos crear en la clase Animal, funciones miembros para cambiar dinámicamente dichos comportamientos. Es decir, en tiempo de ejecución, podemos decirle a un objeto <code>Bird</code> que no puede volar.</p>\n<pre><code class="language-java">    public void setFlyingAbility(FlyBehavior newFlyBehavior){\n        flyBehavior = newFlyBehavior;\n    }\n</code></pre>\n<p>Modificamos nuestro test añadiendo las siguientes líneas:</p>\n<pre><code class="language-java">...\n tweety.setFlyingAbility(new CantFly());\n        tweety.display();\n        tweety.tryToFly();\n...\n</code></pre>\n<p>Ejecutamos nuevamente el programa.</p>\n<p><img src="https://res.cloudinary.com/webxander/image/upload/v1545464516/patterns/zootest2.png" alt="zootest2"></p>\n<p>Hasta aquí, hemos visto como este patrón, define una familia de algoritmos, encapsula cada uno y los hace intercambiables.</p>\n<p>::: info\n<strong>The Strategy Pattern</strong> permite que el algoritmo varíe dependiendo de los clientes que lo utilizan.\n:::</p>\n',attributes:{name:"the-strategy-pattern",title:"The Strategy Pattern",year:"21 de Julio de 2019",color:"#8e7964",trans:"the-strategy-pattern",id:"the-strategy-pattern",description:"The Strategy Pattern o el Patron Estrategia nos permite que el algoritmo varíe dependiendo de los clientes que lo utilizan.\n",_meta:{resourcePath:"/home/travis/build/alejandrocayssials/nuxtblog/contents/articles/the-strategy-pattern.md"}},vue:{render:"return function render() { var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _vm._m(0) }",staticRenderFns:'return [function () { var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(\'div\',{staticClass:"dynamicMarkdown"},[_c(\'h2\',[_vm._v("The Strategy Pattern")]),_vm._v(" "),_c(\'h3\',[_vm._v("Primeros pasos")]),_vm._v(" "),_c(\'p\',[_vm._v("Nos contratan para desarrollar una aplicación que gestione animales de un zoológico. Como sabemos, en un zoo existen diferentes tipos de animales. Por este motivo, inicialmente los diseñadores del sistema han creado una superclase llamada   "),_c(\'code\',{pre:true},[_vm._v("Animal")]),_vm._v(", la cual todos los tipos de animales heredan de ella.")]),_vm._v(" "),_c(\'p\',[_c(\'img\',{attrs:{"src":"https://res.cloudinary.com/webxander/image/upload/v1545464516/patterns/PatronesStrategy.png","alt":"PatronesStrategy"}})]),_vm._v(" "),_c(\'p\',[_vm._v("::: info")]),_vm._v(" "),_c(\'h4\',[_vm._v("Observaciones")]),_vm._v(" "),_c(\'p\',[_vm._v("Todos los animales deben poder emitir un sonido, también deben poder comer, entre otras acciones comunes.\\nCada subtipo de animal, es responsable de implementar el método "),_c(\'code\',{pre:true},[_vm._v("display()")]),_vm._v(" para determinar de que manera será visualizado en pantalla.\\nEl método "),_c(\'code\',{pre:true},[_vm._v("display()")]),_vm._v(" es abstracto, todos los subtipos de animal, lucen de manera diferente.\\n:::")]),_vm._v(" "),_c(\'p\',[_vm._v("En el ultimo año, el gerente del zoológico ha querido comprobar que animales pueden volar y cuáles no. El problema aquí, radica en que no todos los animales tienen pueden volar, por ejemplo, un perro o un gato no vuela, pero un pajaro, si lo hace.")]),_vm._v(" "),_c(\'p\',[_vm._v("El primer diseño que se nos ocurre implementar, es el siguiente:")]),_vm._v(" "),_c(\'p\',[_c(\'img\',{attrs:{"src":"https://res.cloudinary.com/webxander/image/upload/v1545464516/patterns/PatronesStrategy2.png","alt":"PatronesStrategy2"}})]),_vm._v(" "),_c(\'p\',[_vm._v("Perfecto, este diseño añade una función a la superclase "),_c(\'code\',{pre:true},[_vm._v("Animal")]),_vm._v(", llamada "),_c(\'code\',{pre:true},[_vm._v("fly()")]),_vm._v(" y en los subtipos de animales que no puedan volar, se sobrescribe el método retornando un valor nulo.")]),_vm._v(" "),_c(\'p\',[_vm._v("Aquí existe varios inconvenientes. El código es duplicado en las subclases. Por otra parte, es difícil conocer los comportamientos de todos los animales. Además, cada vez que se decida añadir un nuevo tipo de animal, ya sea porque el zoológico va creciendo a lo largo del tiempo, se necesita sobrescribir los métodos en los diferentes tipos de ejemplares. Además, si la aplicación desea también comprobar que animales pueden nadar, debemos hacer exactamente lo mismo en cada uno de los animales que no lo pueden hacer, por lo que el código se hace difícil de mantener.")]),_vm._v(" "),_c(\'h3\',[_vm._v("Separando los comportamientos variables de los comunes")]),_vm._v(" "),_c(\'p\',[_vm._v("¿Por dónde empezamos? Como hemos dicho, existen comportamientos que todos los animales tienen, por ejemplo, el de comer, emitir sonido, caminar, entre otros, y comportamientos que solo una clase de animales poseen, como nadar o volar.")]),_vm._v(" "),_c(\'p\',[_vm._v("Dicho esto, dejemos solo en la clase "),_c(\'code\',{pre:true},[_vm._v("Animal")]),_vm._v(", aquellos comportamientos que no deberían cambiar. Solo vamos a separar aquellas partes que cambian. Para ello, vamos a crear un conjunto de clases fuera de la clase "),_c(\'code\',{pre:true},[_vm._v("Animal")]),_vm._v(". Cada conjunto de clase, contendrá todas las implementaciones de sus respectivos comportamientos. Por ejemplo, nosotros podríamos tener una clase que implemente swinning, otra que implemente running, otra que implemente flying.")]),_vm._v(" "),_c(\'p\',[_vm._v("Como sabemos, las partes de la clase "),_c(\'code\',{pre:true},[_vm._v("Animal")]),_vm._v(" que cambian, es "),_c(\'code\',{pre:true},[_vm._v("fly()")]),_vm._v(". Para separar este comportamiento, lo que haremos será extraer este método y crear un nuevo conjunto de clases para representar esta acción.")]),_vm._v(" "),_c(\'h3\',[_vm._v("Diseñando los comportamientos de la clase Animal")]),_vm._v(" "),_c(\'p\',[_vm._v("Entonces, ¿cómo vamos a diseñar el conjunto de clases que implementan los comportamientos fly? Nos gustaría mantener las cosas flexibles; después de todo, fue la inflexibilidad en los comportamientos de los animales lo que nos metió en problemas en primer lugar. Y sabemos que queremos asignar comportamientos a las instancias de Animal. Por ejemplo, podríamos instanciar una nueva instancia de Butterfly e inicializarla con un tipo específico de comportamiento de vuelo. Y mientras estamos allí, ¿por qué no nos aseguramos de que podamos cambiar el comportamiento de un animal dinámicamente? En otras palabras, deberíamos incluir métodos de establecimiento de comportamiento en las clases de Animal para que podamos, por ejemplo, cambiar el comportamiento de vuelo de Butterfly o Mariposa en tiempo de ejecución. Dados estos objetivos, veamos nuestro segundo principio de diseño: utilizaremos una interfaz para representar cada comportamiento, por ejemplo, "),_c(\'code\',{pre:true},[_vm._v("FlyBehavior")]),_vm._v(", y cada implementación de un comportamiento implementará una de esas interfaces. Haremos un conjunto de clases cuya razón de existir, sea representar un comportamiento (por ejemplo, \\"flying\\"), y es la clase del comportamiento, en lugar de la clase Animal, la que implementará la interfaz del comportamiento. Esto está en contraste con la forma en que hacíamos las cosas antes, donde un comportamiento provenía de una implementación concreta en la superclase Animal, o al proporcionar una implementación especializada en la subclase misma. En ambos casos confiamos en una implementación. Estábamos atrapados en el uso de esa implementación específica y no había lugar para cambiar el comportamiento (que no sea escribir más código). Con nuestro nuevo diseño, las subclases de Animal usarán un comportamiento representado por una interfaz ("),_c(\'code\',{pre:true},[_vm._v("FlyBehavior")]),_vm._v("), de modo que la implementación real del comportamiento (en otras palabras, el comportamiento concreto específico codificado en la clase que implementa "),_c(\'code\',{pre:true},[_vm._v("FlyBehavior")]),_vm._v(") no estará bloqueado en la subclase de Animal.")]),_vm._v(" "),_c(\'p\',[_c(\'img\',{attrs:{"src":"https://res.cloudinary.com/webxander/image/upload/v1545464516/patterns/Patrones-Strategy-Page-2.jpg","alt":"Patrones-Strategy-Page-2"}})]),_vm._v(" "),_c(\'p\',[_vm._v("La clase "),_c(\'code\',{pre:true},[_vm._v("IfFlys")]),_vm._v(" que implementa la interfaz "),_c(\'code\',{pre:true},[_vm._v("FlyBehavior")]),_vm._v(" será usada por todos los animales que puedan volar, en cambio, la clase "),_c(\'code\',{pre:true},[_vm._v("CantFly")]),_vm._v(", será usada por los animales que no puedan volar.")]),_vm._v(" "),_c(\'p\',[_vm._v("Con este diseño, otros tipos de objetos pueden reutilizar nuestros comportamientos de vuelo porque éstos ya no están ocultos en nuestra clase "),_c(\'code\',{pre:true},[_vm._v("Animal")]),_vm._v(".")]),_vm._v(" "),_c(\'p\',[_vm._v("También podemos agregar nuevos comportamientos sin modificar ninguna de sus clases de comportamiento existentes ni tocar ninguna de las clases de "),_c(\'code\',{pre:true},[_vm._v("Animal")]),_vm._v(" que usan comportamientos de vuelo.")]),_vm._v(" "),_c(\'h3\',[_vm._v("Integrando la interfaz FlyBehavior")]),_vm._v(" "),_c(\'p\',[_vm._v("La clave es que un animal ahora delegará su comportamiento de vuelo, en lugar de usar métodos de vuelo definidos en la clase (o subclase) de animal.")]),_vm._v(" "),_c(\'p\',[_vm._v("Primero agregaremos un atributo a la clase "),_c(\'code\',{pre:true},[_vm._v("Animal")]),_vm._v(" llamada"),_c(\'code\',{pre:true},[_vm._v("flyBehavior")]),_vm._v(" que está declarada como interfaz). Cada objeto de animal configurará esta variable polimórficamente para hacer referencia al tipo de comportamiento específico que desearía en el tiempo de ejecución. También eliminaremos el método "),_c(\'code\',{pre:true},[_vm._v("fly()")]),_vm._v(" de la clase Animal (y de cualquier subclase) porque hemos trasladado este comportamiento a la clase "),_c(\'code\',{pre:true},[_vm._v("FlyBehavior")]),_vm._v(". Reemplazaremos "),_c(\'code\',{pre:true},[_vm._v("fly()")]),_vm._v(" en la clase Animal con un método similar, llamado "),_c(\'code\',{pre:true},[_vm._v("tryToFly()")]),_vm._v("; Verás cómo funcionan a continuación.")]),_vm._v(" "),_c(\'p\',[_c(\'img\',{attrs:{"src":"https://res.cloudinary.com/webxander/image/upload/v1545464516/patterns/Patrones-Strategy-Page-3.jpg","alt":"Patrones-Strategy-Page-3"}})]),_vm._v(" "),_c(\'p\',[_vm._v("Ahora implementamos el método "),_c(\'code\',{pre:true},[_vm._v("tryToFly()")])]),_vm._v(" "),_c(\'pre\',[_c(\'code\',{pre:true,attrs:{"class":"language-java"}},[_vm._v("        public class Animal {\\n\\n            FlyBehavior flyBehavior\\n\\n            public void tryToFly()\\n            {\\n                flyBehavior.fly();\\n            }\\n       }\\n")])]),_vm._v(" "),_c(\'p\',[_vm._v("Bastante simple. Ahora como vemos, un animal solo permite que el objeto al que es referenciado "),_c(\'code\',{pre:true},[_vm._v("flyBehavior")]),_vm._v(" pueda comprobar si este vuela o no. En esta parte del código no nos importa qué tipo de objeto es, lo único que nos importa es que sepa cómo vuela, si es que lo hace. De acuerdo, es hora de aprender a utilizar las variables de instancia "),_c(\'code\',{pre:true},[_vm._v("flyBehavior")]),_vm._v(". Echemos un vistazo a la clase "),_c(\'code\',{pre:true},[_vm._v("Bird")])]),_vm._v(" "),_c(\'pre\',[_c(\'code\',{pre:true,attrs:{"class":"language-java"}},[_vm._v("    public class Bird extends Animal {\\n\\n        public Bird()\\n        {\\n            flyBehavior = new ItsFlys();\\n        }\\n\\n        @Override\\n        public void display() {\\n            System.out.println(\\"I\'m a Bird!!\\");\\n        }\\n\\n        public void makeSound()\\n        {\\n            System.out.println(\\"I\'m a Bird,\\n                I can make a cuack!\\");\\n        }\\n}\\n")])]),_vm._v(" "),_c(\'p\',[_vm._v("Como observamos, en el constructor de la clase "),_c(\'code\',{pre:true},[_vm._v("Bird")]),_vm._v(", asignamos una nueva instancia de la clase "),_c(\'code\',{pre:true},[_vm._v("ItsFly")]),_vm._v(" y la guardamos en el atributo "),_c(\'code\',{pre:true},[_vm._v("flyBehavior")]),_vm._v(". Esto quiere decir que, un objeto "),_c(\'code\',{pre:true},[_vm._v("Bird")]),_vm._v(" tiene la capacidad de poder volar, pero si se tratase de un "),_c(\'code\',{pre:true},[_vm._v("Dog")]),_vm._v(", la instancia asignada en el atributo "),_c(\'code\',{pre:true},[_vm._v("flyBehavior")]),_vm._v(" sería "),_c(\'code\',{pre:true},[_vm._v("CantFly()")]),_vm._v(".")]),_vm._v(" "),_c(\'h3\',[_vm._v("Testeando nuestra primera aplicación")]),_vm._v(" "),_c(\'p\',[_vm._v("Vamos a implementar la clase Animal y sus respectivos tipos de animales, ("),_c(\'code\',{pre:true},[_vm._v("Bird")]),_vm._v(" y "),_c(\'code\',{pre:true},[_vm._v("Dog")]),_vm._v("), también crearemos la interfaz "),_c(\'code\',{pre:true},[_vm._v("FlyBehavior")]),_vm._v(" y sus conjuntos de clases que implementan esta interfaz.")]),_vm._v(" "),_c(\'pre\',[_c(\'code\',{pre:true,attrs:{"class":"language-java"}},[_vm._v("    public abstract class Animal {\\n\\n            FlyBehavior flyBehavior;\\n\\n            public Animal(){\\n\\n            }\\n\\n            public abstract void display();\\n\\n            public void makeSound()\\n            {\\n                System.out.println(\\"I\'m a Animal, I can make a sound\\");\\n            }\\n\\n            public void eat()\\n            {\\n                System.out.println(\\"I\'m a Animal, I can eat a food\\");\\n            }\\n\\n            public void tryToFly()\\n            {\\n                flyBehavior.fly();\\n            }\\n\\n        }\\n")])]),_vm._v(" "),_c(\'pre\',[_c(\'code\',{pre:true,attrs:{"class":"language-java"}},[_vm._v("    public class Bird extends Animal {\\n\\n            public Bird()\\n            {\\n                flyBehavior = new ItsFlys();\\n            }\\n\\n            @Override\\n            public void display() {\\n                System.out.println(\\"I\'m a Bird!!\\");\\n            }\\n\\n            public void makeSound()\\n            {\\n                System.out.println(\\"I\'m a Bird, I can make a cuack!\\");\\n            }\\n\\n}\\n")])]),_vm._v(" "),_c(\'pre\',[_c(\'code\',{pre:true,attrs:{"class":"language-java"}},[_vm._v("    public class Dog extends Animal {\\n\\n            public Dog()\\n            {\\n                flyBehavior = new CantFly();\\n            }\\n\\n            @Override\\n            public void display() {\\n                System.out.println(\\"I\'m a Dog!!\\");\\n            }\\n\\n            public void makeSound()\\n            {\\n                System.out.println(\\"I\'m a Dog, I can make a guau!\\");\\n            }\\n\\n        }\\n")])]),_vm._v(" "),_c(\'pre\',[_c(\'code\',{pre:true,attrs:{"class":"language-java"}},[_vm._v("    public interface FlyBehavior {\\n\\n        public void fly();\\n    }\\n")])]),_vm._v(" "),_c(\'pre\',[_c(\'code\',{pre:true,attrs:{"class":"language-java"}},[_vm._v("\\n    public class ItsFlys implements FlyBehavior {\\n\\n        @Override\\n        public void fly() {\\n            System.out.println(\\"I can fly!\\");\\n        }\\n\\n    }\\n")])]),_vm._v(" "),_c(\'pre\',[_c(\'code\',{pre:true,attrs:{"class":"language-java"}},[_vm._v("    public class CantFly implements FlyBehavior {\\n\\n        @Override\\n        public void fly() {\\n            System.out.println(\\"I can\'t fly...\\");\\n        }\\n\\n    }\\n")])]),_vm._v(" "),_c(\'p\',[_vm._v("Ahora vamos a crear un mini test para verificar la funcionalidad de las mismas.")]),_vm._v(" "),_c(\'pre\',[_c(\'code\',{pre:true,attrs:{"class":"language-java"}},[_vm._v("    public class ZooTest {\\n            public static void main(String[] args)\\n            {\\n                Animal tweety = new Bird();\\n\\n                tweety.tryToFly();\\n\\n                tweety.display();\\n\\n                Animal snoopy = new Dog();\\n\\n                snoopy.tryToFly();\\n\\n                snoopy.display();\\n\\n            }\\n        }\\n")])]),_vm._v(" "),_c(\'p\',[_vm._v("Perfecto, ejecutamos dicho test y veremos en la consola de nuestro IDE el siguiente resultado:")]),_vm._v(" "),_c(\'p\',[_c(\'img\',{attrs:{"src":"https://res.cloudinary.com/webxander/image/upload/v1545464516/patterns/zootest.png","alt":"zootest"}})]),_vm._v(" "),_c(\'h3\',[_vm._v("Añadiendo comportamientos dinámicamente")]),_vm._v(" "),_c(\'p\',[_vm._v("Ahora podemos crear en la clase Animal, funciones miembros para cambiar dinámicamente dichos comportamientos. Es decir, en tiempo de ejecución, podemos decirle a un objeto "),_c(\'code\',{pre:true},[_vm._v("Bird")]),_vm._v(" que no puede volar.")]),_vm._v(" "),_c(\'pre\',[_c(\'code\',{pre:true,attrs:{"class":"language-java"}},[_vm._v("    public void setFlyingAbility(FlyBehavior newFlyBehavior){\\n        flyBehavior = newFlyBehavior;\\n    }\\n")])]),_vm._v(" "),_c(\'p\',[_vm._v("Modificamos nuestro test añadiendo las siguientes líneas:")]),_vm._v(" "),_c(\'pre\',[_c(\'code\',{pre:true,attrs:{"class":"language-java"}},[_vm._v("...\\n tweety.setFlyingAbility(new CantFly());\\n        tweety.display();\\n        tweety.tryToFly();\\n...\\n")])]),_vm._v(" "),_c(\'p\',[_vm._v("Ejecutamos nuevamente el programa.")]),_vm._v(" "),_c(\'p\',[_c(\'img\',{attrs:{"src":"https://res.cloudinary.com/webxander/image/upload/v1545464516/patterns/zootest2.png","alt":"zootest2"}})]),_vm._v(" "),_c(\'p\',[_vm._v("Hasta aquí, hemos visto como este patrón, define una familia de algoritmos, encapsula cada uno y los hace intercambiables.")]),_vm._v(" "),_c(\'p\',[_vm._v("::: info\\n"),_c(\'strong\',[_vm._v("The Strategy Pattern")]),_vm._v(" permite que el algoritmo varíe dependiendo de los clientes que lo utilizan.\\n:::")])]) }]',component:{data:function(){return{templateRender:null}},render:function(e){return this.templateRender?this.templateRender():e("div","Rendering")},created:function(){this.templateRender=function(){var e=this.$createElement;this._self._c;return this._m(0)},this.$options.staticRenderFns=[function(){var e=this,o=e.$createElement,n=e._self._c||o;return n("div",{staticClass:"dynamicMarkdown"},[n("h2",[e._v("The Strategy Pattern")]),e._v(" "),n("h3",[e._v("Primeros pasos")]),e._v(" "),n("p",[e._v("Nos contratan para desarrollar una aplicación que gestione animales de un zoológico. Como sabemos, en un zoo existen diferentes tipos de animales. Por este motivo, inicialmente los diseñadores del sistema han creado una superclase llamada   "),n("code",{pre:!0},[e._v("Animal")]),e._v(", la cual todos los tipos de animales heredan de ella.")]),e._v(" "),n("p",[n("img",{attrs:{src:"https://res.cloudinary.com/webxander/image/upload/v1545464516/patterns/PatronesStrategy.png",alt:"PatronesStrategy"}})]),e._v(" "),n("p",[e._v("::: info")]),e._v(" "),n("h4",[e._v("Observaciones")]),e._v(" "),n("p",[e._v("Todos los animales deben poder emitir un sonido, también deben poder comer, entre otras acciones comunes.\nCada subtipo de animal, es responsable de implementar el método "),n("code",{pre:!0},[e._v("display()")]),e._v(" para determinar de que manera será visualizado en pantalla.\nEl método "),n("code",{pre:!0},[e._v("display()")]),e._v(" es abstracto, todos los subtipos de animal, lucen de manera diferente.\n:::")]),e._v(" "),n("p",[e._v("En el ultimo año, el gerente del zoológico ha querido comprobar que animales pueden volar y cuáles no. El problema aquí, radica en que no todos los animales tienen pueden volar, por ejemplo, un perro o un gato no vuela, pero un pajaro, si lo hace.")]),e._v(" "),n("p",[e._v("El primer diseño que se nos ocurre implementar, es el siguiente:")]),e._v(" "),n("p",[n("img",{attrs:{src:"https://res.cloudinary.com/webxander/image/upload/v1545464516/patterns/PatronesStrategy2.png",alt:"PatronesStrategy2"}})]),e._v(" "),n("p",[e._v("Perfecto, este diseño añade una función a la superclase "),n("code",{pre:!0},[e._v("Animal")]),e._v(", llamada "),n("code",{pre:!0},[e._v("fly()")]),e._v(" y en los subtipos de animales que no puedan volar, se sobrescribe el método retornando un valor nulo.")]),e._v(" "),n("p",[e._v("Aquí existe varios inconvenientes. El código es duplicado en las subclases. Por otra parte, es difícil conocer los comportamientos de todos los animales. Además, cada vez que se decida añadir un nuevo tipo de animal, ya sea porque el zoológico va creciendo a lo largo del tiempo, se necesita sobrescribir los métodos en los diferentes tipos de ejemplares. Además, si la aplicación desea también comprobar que animales pueden nadar, debemos hacer exactamente lo mismo en cada uno de los animales que no lo pueden hacer, por lo que el código se hace difícil de mantener.")]),e._v(" "),n("h3",[e._v("Separando los comportamientos variables de los comunes")]),e._v(" "),n("p",[e._v("¿Por dónde empezamos? Como hemos dicho, existen comportamientos que todos los animales tienen, por ejemplo, el de comer, emitir sonido, caminar, entre otros, y comportamientos que solo una clase de animales poseen, como nadar o volar.")]),e._v(" "),n("p",[e._v("Dicho esto, dejemos solo en la clase "),n("code",{pre:!0},[e._v("Animal")]),e._v(", aquellos comportamientos que no deberían cambiar. Solo vamos a separar aquellas partes que cambian. Para ello, vamos a crear un conjunto de clases fuera de la clase "),n("code",{pre:!0},[e._v("Animal")]),e._v(". Cada conjunto de clase, contendrá todas las implementaciones de sus respectivos comportamientos. Por ejemplo, nosotros podríamos tener una clase que implemente swinning, otra que implemente running, otra que implemente flying.")]),e._v(" "),n("p",[e._v("Como sabemos, las partes de la clase "),n("code",{pre:!0},[e._v("Animal")]),e._v(" que cambian, es "),n("code",{pre:!0},[e._v("fly()")]),e._v(". Para separar este comportamiento, lo que haremos será extraer este método y crear un nuevo conjunto de clases para representar esta acción.")]),e._v(" "),n("h3",[e._v("Diseñando los comportamientos de la clase Animal")]),e._v(" "),n("p",[e._v("Entonces, ¿cómo vamos a diseñar el conjunto de clases que implementan los comportamientos fly? Nos gustaría mantener las cosas flexibles; después de todo, fue la inflexibilidad en los comportamientos de los animales lo que nos metió en problemas en primer lugar. Y sabemos que queremos asignar comportamientos a las instancias de Animal. Por ejemplo, podríamos instanciar una nueva instancia de Butterfly e inicializarla con un tipo específico de comportamiento de vuelo. Y mientras estamos allí, ¿por qué no nos aseguramos de que podamos cambiar el comportamiento de un animal dinámicamente? En otras palabras, deberíamos incluir métodos de establecimiento de comportamiento en las clases de Animal para que podamos, por ejemplo, cambiar el comportamiento de vuelo de Butterfly o Mariposa en tiempo de ejecución. Dados estos objetivos, veamos nuestro segundo principio de diseño: utilizaremos una interfaz para representar cada comportamiento, por ejemplo, "),n("code",{pre:!0},[e._v("FlyBehavior")]),e._v(', y cada implementación de un comportamiento implementará una de esas interfaces. Haremos un conjunto de clases cuya razón de existir, sea representar un comportamiento (por ejemplo, "flying"), y es la clase del comportamiento, en lugar de la clase Animal, la que implementará la interfaz del comportamiento. Esto está en contraste con la forma en que hacíamos las cosas antes, donde un comportamiento provenía de una implementación concreta en la superclase Animal, o al proporcionar una implementación especializada en la subclase misma. En ambos casos confiamos en una implementación. Estábamos atrapados en el uso de esa implementación específica y no había lugar para cambiar el comportamiento (que no sea escribir más código). Con nuestro nuevo diseño, las subclases de Animal usarán un comportamiento representado por una interfaz ('),n("code",{pre:!0},[e._v("FlyBehavior")]),e._v("), de modo que la implementación real del comportamiento (en otras palabras, el comportamiento concreto específico codificado en la clase que implementa "),n("code",{pre:!0},[e._v("FlyBehavior")]),e._v(") no estará bloqueado en la subclase de Animal.")]),e._v(" "),n("p",[n("img",{attrs:{src:"https://res.cloudinary.com/webxander/image/upload/v1545464516/patterns/Patrones-Strategy-Page-2.jpg",alt:"Patrones-Strategy-Page-2"}})]),e._v(" "),n("p",[e._v("La clase "),n("code",{pre:!0},[e._v("IfFlys")]),e._v(" que implementa la interfaz "),n("code",{pre:!0},[e._v("FlyBehavior")]),e._v(" será usada por todos los animales que puedan volar, en cambio, la clase "),n("code",{pre:!0},[e._v("CantFly")]),e._v(", será usada por los animales que no puedan volar.")]),e._v(" "),n("p",[e._v("Con este diseño, otros tipos de objetos pueden reutilizar nuestros comportamientos de vuelo porque éstos ya no están ocultos en nuestra clase "),n("code",{pre:!0},[e._v("Animal")]),e._v(".")]),e._v(" "),n("p",[e._v("También podemos agregar nuevos comportamientos sin modificar ninguna de sus clases de comportamiento existentes ni tocar ninguna de las clases de "),n("code",{pre:!0},[e._v("Animal")]),e._v(" que usan comportamientos de vuelo.")]),e._v(" "),n("h3",[e._v("Integrando la interfaz FlyBehavior")]),e._v(" "),n("p",[e._v("La clave es que un animal ahora delegará su comportamiento de vuelo, en lugar de usar métodos de vuelo definidos en la clase (o subclase) de animal.")]),e._v(" "),n("p",[e._v("Primero agregaremos un atributo a la clase "),n("code",{pre:!0},[e._v("Animal")]),e._v(" llamada"),n("code",{pre:!0},[e._v("flyBehavior")]),e._v(" que está declarada como interfaz). Cada objeto de animal configurará esta variable polimórficamente para hacer referencia al tipo de comportamiento específico que desearía en el tiempo de ejecución. También eliminaremos el método "),n("code",{pre:!0},[e._v("fly()")]),e._v(" de la clase Animal (y de cualquier subclase) porque hemos trasladado este comportamiento a la clase "),n("code",{pre:!0},[e._v("FlyBehavior")]),e._v(". Reemplazaremos "),n("code",{pre:!0},[e._v("fly()")]),e._v(" en la clase Animal con un método similar, llamado "),n("code",{pre:!0},[e._v("tryToFly()")]),e._v("; Verás cómo funcionan a continuación.")]),e._v(" "),n("p",[n("img",{attrs:{src:"https://res.cloudinary.com/webxander/image/upload/v1545464516/patterns/Patrones-Strategy-Page-3.jpg",alt:"Patrones-Strategy-Page-3"}})]),e._v(" "),n("p",[e._v("Ahora implementamos el método "),n("code",{pre:!0},[e._v("tryToFly()")])]),e._v(" "),n("pre",[n("code",{pre:!0,attrs:{class:"language-java"}},[e._v("        public class Animal {\n\n            FlyBehavior flyBehavior\n\n            public void tryToFly()\n            {\n                flyBehavior.fly();\n            }\n       }\n")])]),e._v(" "),n("p",[e._v("Bastante simple. Ahora como vemos, un animal solo permite que el objeto al que es referenciado "),n("code",{pre:!0},[e._v("flyBehavior")]),e._v(" pueda comprobar si este vuela o no. En esta parte del código no nos importa qué tipo de objeto es, lo único que nos importa es que sepa cómo vuela, si es que lo hace. De acuerdo, es hora de aprender a utilizar las variables de instancia "),n("code",{pre:!0},[e._v("flyBehavior")]),e._v(". Echemos un vistazo a la clase "),n("code",{pre:!0},[e._v("Bird")])]),e._v(" "),n("pre",[n("code",{pre:!0,attrs:{class:"language-java"}},[e._v('    public class Bird extends Animal {\n\n        public Bird()\n        {\n            flyBehavior = new ItsFlys();\n        }\n\n        @Override\n        public void display() {\n            System.out.println("I\'m a Bird!!");\n        }\n\n        public void makeSound()\n        {\n            System.out.println("I\'m a Bird,\n                I can make a cuack!");\n        }\n}\n')])]),e._v(" "),n("p",[e._v("Como observamos, en el constructor de la clase "),n("code",{pre:!0},[e._v("Bird")]),e._v(", asignamos una nueva instancia de la clase "),n("code",{pre:!0},[e._v("ItsFly")]),e._v(" y la guardamos en el atributo "),n("code",{pre:!0},[e._v("flyBehavior")]),e._v(". Esto quiere decir que, un objeto "),n("code",{pre:!0},[e._v("Bird")]),e._v(" tiene la capacidad de poder volar, pero si se tratase de un "),n("code",{pre:!0},[e._v("Dog")]),e._v(", la instancia asignada en el atributo "),n("code",{pre:!0},[e._v("flyBehavior")]),e._v(" sería "),n("code",{pre:!0},[e._v("CantFly()")]),e._v(".")]),e._v(" "),n("h3",[e._v("Testeando nuestra primera aplicación")]),e._v(" "),n("p",[e._v("Vamos a implementar la clase Animal y sus respectivos tipos de animales, ("),n("code",{pre:!0},[e._v("Bird")]),e._v(" y "),n("code",{pre:!0},[e._v("Dog")]),e._v("), también crearemos la interfaz "),n("code",{pre:!0},[e._v("FlyBehavior")]),e._v(" y sus conjuntos de clases que implementan esta interfaz.")]),e._v(" "),n("pre",[n("code",{pre:!0,attrs:{class:"language-java"}},[e._v('    public abstract class Animal {\n\n            FlyBehavior flyBehavior;\n\n            public Animal(){\n\n            }\n\n            public abstract void display();\n\n            public void makeSound()\n            {\n                System.out.println("I\'m a Animal, I can make a sound");\n            }\n\n            public void eat()\n            {\n                System.out.println("I\'m a Animal, I can eat a food");\n            }\n\n            public void tryToFly()\n            {\n                flyBehavior.fly();\n            }\n\n        }\n')])]),e._v(" "),n("pre",[n("code",{pre:!0,attrs:{class:"language-java"}},[e._v('    public class Bird extends Animal {\n\n            public Bird()\n            {\n                flyBehavior = new ItsFlys();\n            }\n\n            @Override\n            public void display() {\n                System.out.println("I\'m a Bird!!");\n            }\n\n            public void makeSound()\n            {\n                System.out.println("I\'m a Bird, I can make a cuack!");\n            }\n\n}\n')])]),e._v(" "),n("pre",[n("code",{pre:!0,attrs:{class:"language-java"}},[e._v('    public class Dog extends Animal {\n\n            public Dog()\n            {\n                flyBehavior = new CantFly();\n            }\n\n            @Override\n            public void display() {\n                System.out.println("I\'m a Dog!!");\n            }\n\n            public void makeSound()\n            {\n                System.out.println("I\'m a Dog, I can make a guau!");\n            }\n\n        }\n')])]),e._v(" "),n("pre",[n("code",{pre:!0,attrs:{class:"language-java"}},[e._v("    public interface FlyBehavior {\n\n        public void fly();\n    }\n")])]),e._v(" "),n("pre",[n("code",{pre:!0,attrs:{class:"language-java"}},[e._v('\n    public class ItsFlys implements FlyBehavior {\n\n        @Override\n        public void fly() {\n            System.out.println("I can fly!");\n        }\n\n    }\n')])]),e._v(" "),n("pre",[n("code",{pre:!0,attrs:{class:"language-java"}},[e._v('    public class CantFly implements FlyBehavior {\n\n        @Override\n        public void fly() {\n            System.out.println("I can\'t fly...");\n        }\n\n    }\n')])]),e._v(" "),n("p",[e._v("Ahora vamos a crear un mini test para verificar la funcionalidad de las mismas.")]),e._v(" "),n("pre",[n("code",{pre:!0,attrs:{class:"language-java"}},[e._v("    public class ZooTest {\n            public static void main(String[] args)\n            {\n                Animal tweety = new Bird();\n\n                tweety.tryToFly();\n\n                tweety.display();\n\n                Animal snoopy = new Dog();\n\n                snoopy.tryToFly();\n\n                snoopy.display();\n\n            }\n        }\n")])]),e._v(" "),n("p",[e._v("Perfecto, ejecutamos dicho test y veremos en la consola de nuestro IDE el siguiente resultado:")]),e._v(" "),n("p",[n("img",{attrs:{src:"https://res.cloudinary.com/webxander/image/upload/v1545464516/patterns/zootest.png",alt:"zootest"}})]),e._v(" "),n("h3",[e._v("Añadiendo comportamientos dinámicamente")]),e._v(" "),n("p",[e._v("Ahora podemos crear en la clase Animal, funciones miembros para cambiar dinámicamente dichos comportamientos. Es decir, en tiempo de ejecución, podemos decirle a un objeto "),n("code",{pre:!0},[e._v("Bird")]),e._v(" que no puede volar.")]),e._v(" "),n("pre",[n("code",{pre:!0,attrs:{class:"language-java"}},[e._v("    public void setFlyingAbility(FlyBehavior newFlyBehavior){\n        flyBehavior = newFlyBehavior;\n    }\n")])]),e._v(" "),n("p",[e._v("Modificamos nuestro test añadiendo las siguientes líneas:")]),e._v(" "),n("pre",[n("code",{pre:!0,attrs:{class:"language-java"}},[e._v("...\n tweety.setFlyingAbility(new CantFly());\n        tweety.display();\n        tweety.tryToFly();\n...\n")])]),e._v(" "),n("p",[e._v("Ejecutamos nuevamente el programa.")]),e._v(" "),n("p",[n("img",{attrs:{src:"https://res.cloudinary.com/webxander/image/upload/v1545464516/patterns/zootest2.png",alt:"zootest2"}})]),e._v(" "),n("p",[e._v("Hasta aquí, hemos visto como este patrón, define una familia de algoritmos, encapsula cada uno y los hace intercambiables.")]),e._v(" "),n("p",[e._v("::: info\n"),n("strong",[e._v("The Strategy Pattern")]),e._v(" permite que el algoritmo varíe dependiendo de los clientes que lo utilizan.\n:::")])])}]}}}}}}]);