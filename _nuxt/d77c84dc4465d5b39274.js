(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{389:function(e,n){e.exports={body:"# Patrones de diseño\n\n## Introducción\n\nEn el desarrollo de sistemas, la mayoría de los programadores hoy en día, utilizan como metodología, la Programación Orientada a Objetos, de aquí en adelante, lo abreviaremos con sus siglas POO. Sabemos que programar en POO, no es muy sencillo, cuando los desarrollos tienden a complejizarse, el programador no experimentado no es capaz de determinar que clases elaborar. Los conceptos de la POO, no adquieren mayores dificultades a la hora de estudiarlos, el problema radica en como aplicar eficientemente estos conceptos en el desarrollo de aplicaciones medianamente complejas. Para facilitar el desarrollo, existen una serie de patrones, utilizados por una gran mayoría de desarrolladores experimentados, con el propósito de diseñar la arquitectura de sus proyectos.\n\nEn esta guía, vas a aprender a utilizar los diferentes patrones de diseño que podemos encontrar. Usted puede implementar estos patrones, en sus proyectos a medida que su aplicación lo requiera. Debes tener en cuenta, que cada aplicación es diferente, por lo tanto, su comportamiento y su jerarquía de clases será diferente, por eso es indispensable antes que nada, evaluar cual es el patrón de diseño que mejor se adapte a nuestra solución.\n\n## Organización de la guía\n\nAntes de comenzar a definir cada uno de los patrones de diseño, comentaré como será nuestro espacio de trabajo. En primer lugar, cada patrón será definido utilizando un ejemplo básico desarrollado en Java y a continuación, implementaré el patrón en una aplicación real.\n\nLa aplicación a desarrollar será una tienda online realizada en PHP y a medida que irás aprendiendo cada patrón, actualizaremos la tienda con el patrón correspondiente. Por lo tanto, si bien puedes estudiar los mismos por separado, para seguir el avance de esta tienda, te recomiendo que leas la presente guía en orden.\n\n## Strategy (Estrategia)\n\nEl Patrón de Estrategia define una familia de algoritmos, encapsula cada uno y los hace intercambiables. La estrategia permite que el algoritmo varíe independientemente de los clientes que lo utilizan.\n\n## Observer (Observador)\n\nEl Patrón de observador define una dependencia de uno a muchos entre objetos, de modo que cuando un objeto cambia de estado, todos sus dependientes son notificados y actualizados automáticamente.\n\n## Abstract Factory (Fábrica Abstracta)\n\nProporciona una interfaz para crear familias de objetos relacionados o que dependen entre sí.\n\n## Adapter (Adaptador)\n\nConvierte la interfaz de una clase en otra distinta que es la que esperan los clientes. Permite que cooperen clases que de otra manera no podrían por tener interfaces incompatibles.\n\n## Bridge (Puente)\n\nDesacopla una abstracción de su implementación, de manera que ambas puedan variar de forma independiente.\n\n## Builder (Constructor)\n\nSepara la construcción de un objeto complejo de su representación, de forma que el mismo proceso de construcción pueda crear diferentes representaciones.\n\n## Chain of Responsibility (Cadena de Responsabilidad)\n\nEvita acoplar el emisor de una petición a su receptor, al dar a mas de un objeto la posibilidad de responder a la petición. Crea una cadena con los objetos receptores y pasa la petición a través de la cadena hasta que ésta sea trata por algún objeto.\n\n## Command (Orden)\n\nEncapsula una petición en un objeto, permitiendo así parametrizar a los clientes con distintas peticiones, encolar o llevar un registro de las peticiones y poder deshacer las operaciones.\n\n## Composite (Compuesto)\n\nCombina objetos en estructuras de árbol para representar jerarquías de parte-todo. Pemite que los clientes traten de manera uniforme a los objetos individuales y a los compuestos.\n\n## Decorator (Decorador)\n\nAñade dinámicamente nuevas responsabilidades a un objeto, proporcionando una alternativa flexible a la herencia para extender la funcionalidad.\n\n## Facade (Fachada)\n\nProporciona una interfaz unificada para un conjunto de interfaces de un subsistema. Define una interfaz de alto nivel que hace que el subsistema sea más fácil de usar.\n\n## Factory Method (Método de Fabricación)\n\nDefine una interfaz para crear un objeto, pero deja que sean las subclases quienes decidan que clase instanciar. Permite que una clase delegue en sus subclases la creación de objetos.\n\n## Flyweight (Peso Ligero)\n\nUsa el comportamiento para permitir un gran número de objetos de grano fino de forma eficiente.\n\n## Interpreter (Intérprete)\n\nDado un lenguaje, define una representación de su gramática junto con un intérprete que usa dicha representación para interpretar sentencias del lenguaje.\n\n## Iterator (Iterador)\n\nProporciona un modo de acceder secuencialmente a los elementos de un objeto agregado sin exponer su representación interna.\n\n## Mediator (Mediador)\n\nDefine un objeto que encapsula cómo interactúan un conjunto de objetos. Promueve un bajo acoplamiento al evitar que los objetos se refieran unos a otros explícitamente, y permite variar la interacción entre ellos de forma independiente.\n\n## Memento (Recuerdo)\n\nRepresenta y externaliza el estado interno de un objeto sin violar la encapsulación, de forma que éste puede volver a dicho estado más tarde.\n\n## Prototype (Prototipo)\n\nEspecifica los tipos de objetos a crear por medio de una instancia prototípica, y crea nuevos objetos copiando de este prototipo.\n\n## Proxy (Apoderado)\n\nProporciona un sustituto o representante de otro objeto para controlar el acceso a éste.\n\n## Singleton (Único)\n\nGarantiza que una clase sólo tenga una instancia, y proporciona un punto de acceso global a ella.\n\n## State (Estado)\n\nPermite que un objeto modifique su comportamiento cada vez que cambie su estado interno. Parecerá que cambia la clase del objeto.\n\n## Template Method (Método Plantilla)\n\nDefine en una operación el esqueleto de un algoritmo, delegando en las subclases algunos de sus pasos. Permite que las subclases redefinan ciertos pasos del algoritmo sin cambiar su estructura.\n\n## Visitor (Visitante)\n\nRepresenta una operación sobre los elementos de una estructura de objetos. Permite definir una nueva operación sin cambiar las clases de los elementos sobre los que opera.\n",html:"<h1>Patrones de diseño</h1>\n<h2>Introducción</h2>\n<p>En el desarrollo de sistemas, la mayoría de los programadores hoy en día, utilizan como metodología, la Programación Orientada a Objetos, de aquí en adelante, lo abreviaremos con sus siglas POO. Sabemos que programar en POO, no es muy sencillo, cuando los desarrollos tienden a complejizarse, el programador no experimentado no es capaz de determinar que clases elaborar. Los conceptos de la POO, no adquieren mayores dificultades a la hora de estudiarlos, el problema radica en como aplicar eficientemente estos conceptos en el desarrollo de aplicaciones medianamente complejas. Para facilitar el desarrollo, existen una serie de patrones, utilizados por una gran mayoría de desarrolladores experimentados, con el propósito de diseñar la arquitectura de sus proyectos.</p>\n<p>En esta guía, vas a aprender a utilizar los diferentes patrones de diseño que podemos encontrar. Usted puede implementar estos patrones, en sus proyectos a medida que su aplicación lo requiera. Debes tener en cuenta, que cada aplicación es diferente, por lo tanto, su comportamiento y su jerarquía de clases será diferente, por eso es indispensable antes que nada, evaluar cual es el patrón de diseño que mejor se adapte a nuestra solución.</p>\n<h2>Organización de la guía</h2>\n<p>Antes de comenzar a definir cada uno de los patrones de diseño, comentaré como será nuestro espacio de trabajo. En primer lugar, cada patrón será definido utilizando un ejemplo básico desarrollado en Java y a continuación, implementaré el patrón en una aplicación real.</p>\n<p>La aplicación a desarrollar será una tienda online realizada en PHP y a medida que irás aprendiendo cada patrón, actualizaremos la tienda con el patrón correspondiente. Por lo tanto, si bien puedes estudiar los mismos por separado, para seguir el avance de esta tienda, te recomiendo que leas la presente guía en orden.</p>\n<h2>Strategy (Estrategia)</h2>\n<p>El Patrón de Estrategia define una familia de algoritmos, encapsula cada uno y los hace intercambiables. La estrategia permite que el algoritmo varíe independientemente de los clientes que lo utilizan.</p>\n<h2>Observer (Observador)</h2>\n<p>El Patrón de observador define una dependencia de uno a muchos entre objetos, de modo que cuando un objeto cambia de estado, todos sus dependientes son notificados y actualizados automáticamente.</p>\n<h2>Abstract Factory (Fábrica Abstracta)</h2>\n<p>Proporciona una interfaz para crear familias de objetos relacionados o que dependen entre sí.</p>\n<h2>Adapter (Adaptador)</h2>\n<p>Convierte la interfaz de una clase en otra distinta que es la que esperan los clientes. Permite que cooperen clases que de otra manera no podrían por tener interfaces incompatibles.</p>\n<h2>Bridge (Puente)</h2>\n<p>Desacopla una abstracción de su implementación, de manera que ambas puedan variar de forma independiente.</p>\n<h2>Builder (Constructor)</h2>\n<p>Separa la construcción de un objeto complejo de su representación, de forma que el mismo proceso de construcción pueda crear diferentes representaciones.</p>\n<h2>Chain of Responsibility (Cadena de Responsabilidad)</h2>\n<p>Evita acoplar el emisor de una petición a su receptor, al dar a mas de un objeto la posibilidad de responder a la petición. Crea una cadena con los objetos receptores y pasa la petición a través de la cadena hasta que ésta sea trata por algún objeto.</p>\n<h2>Command (Orden)</h2>\n<p>Encapsula una petición en un objeto, permitiendo así parametrizar a los clientes con distintas peticiones, encolar o llevar un registro de las peticiones y poder deshacer las operaciones.</p>\n<h2>Composite (Compuesto)</h2>\n<p>Combina objetos en estructuras de árbol para representar jerarquías de parte-todo. Pemite que los clientes traten de manera uniforme a los objetos individuales y a los compuestos.</p>\n<h2>Decorator (Decorador)</h2>\n<p>Añade dinámicamente nuevas responsabilidades a un objeto, proporcionando una alternativa flexible a la herencia para extender la funcionalidad.</p>\n<h2>Facade (Fachada)</h2>\n<p>Proporciona una interfaz unificada para un conjunto de interfaces de un subsistema. Define una interfaz de alto nivel que hace que el subsistema sea más fácil de usar.</p>\n<h2>Factory Method (Método de Fabricación)</h2>\n<p>Define una interfaz para crear un objeto, pero deja que sean las subclases quienes decidan que clase instanciar. Permite que una clase delegue en sus subclases la creación de objetos.</p>\n<h2>Flyweight (Peso Ligero)</h2>\n<p>Usa el comportamiento para permitir un gran número de objetos de grano fino de forma eficiente.</p>\n<h2>Interpreter (Intérprete)</h2>\n<p>Dado un lenguaje, define una representación de su gramática junto con un intérprete que usa dicha representación para interpretar sentencias del lenguaje.</p>\n<h2>Iterator (Iterador)</h2>\n<p>Proporciona un modo de acceder secuencialmente a los elementos de un objeto agregado sin exponer su representación interna.</p>\n<h2>Mediator (Mediador)</h2>\n<p>Define un objeto que encapsula cómo interactúan un conjunto de objetos. Promueve un bajo acoplamiento al evitar que los objetos se refieran unos a otros explícitamente, y permite variar la interacción entre ellos de forma independiente.</p>\n<h2>Memento (Recuerdo)</h2>\n<p>Representa y externaliza el estado interno de un objeto sin violar la encapsulación, de forma que éste puede volver a dicho estado más tarde.</p>\n<h2>Prototype (Prototipo)</h2>\n<p>Especifica los tipos de objetos a crear por medio de una instancia prototípica, y crea nuevos objetos copiando de este prototipo.</p>\n<h2>Proxy (Apoderado)</h2>\n<p>Proporciona un sustituto o representante de otro objeto para controlar el acceso a éste.</p>\n<h2>Singleton (Único)</h2>\n<p>Garantiza que una clase sólo tenga una instancia, y proporciona un punto de acceso global a ella.</p>\n<h2>State (Estado)</h2>\n<p>Permite que un objeto modifique su comportamiento cada vez que cambie su estado interno. Parecerá que cambia la clase del objeto.</p>\n<h2>Template Method (Método Plantilla)</h2>\n<p>Define en una operación el esqueleto de un algoritmo, delegando en las subclases algunos de sus pasos. Permite que las subclases redefinan ciertos pasos del algoritmo sin cambiar su estructura.</p>\n<h2>Visitor (Visitante)</h2>\n<p>Representa una operación sobre los elementos de una estructura de objetos. Permite definir una nueva operación sin cambiar las clases de los elementos sobre los que opera.</p>\n",attributes:{name:"introduction-to-design-patterns",title:"Introducción a los patrones de diseño.",year:"20 de Julio de 2019",color:"#8e7964",trans:"introduction-to-design-patterns",id:"design-patterns",description:"Breve introducción a los diferentes patrones de diseño que podemos encontrar en el mundo de la programación.\n",_meta:{resourcePath:"/home/travis/build/alejandrocayssials/nuxtblog/contents/articles/introduction-to-design-patterns.md"}},vue:{render:"return function render() { var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _vm._m(0) }",staticRenderFns:'return [function () { var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(\'div\',{staticClass:"dynamicMarkdown"},[_c(\'h1\',[_vm._v("Patrones de diseño")]),_vm._v(" "),_c(\'h2\',[_vm._v("Introducción")]),_vm._v(" "),_c(\'p\',[_vm._v("En el desarrollo de sistemas, la mayoría de los programadores hoy en día, utilizan como metodología, la Programación Orientada a Objetos, de aquí en adelante, lo abreviaremos con sus siglas POO. Sabemos que programar en POO, no es muy sencillo, cuando los desarrollos tienden a complejizarse, el programador no experimentado no es capaz de determinar que clases elaborar. Los conceptos de la POO, no adquieren mayores dificultades a la hora de estudiarlos, el problema radica en como aplicar eficientemente estos conceptos en el desarrollo de aplicaciones medianamente complejas. Para facilitar el desarrollo, existen una serie de patrones, utilizados por una gran mayoría de desarrolladores experimentados, con el propósito de diseñar la arquitectura de sus proyectos.")]),_vm._v(" "),_c(\'p\',[_vm._v("En esta guía, vas a aprender a utilizar los diferentes patrones de diseño que podemos encontrar. Usted puede implementar estos patrones, en sus proyectos a medida que su aplicación lo requiera. Debes tener en cuenta, que cada aplicación es diferente, por lo tanto, su comportamiento y su jerarquía de clases será diferente, por eso es indispensable antes que nada, evaluar cual es el patrón de diseño que mejor se adapte a nuestra solución.")]),_vm._v(" "),_c(\'h2\',[_vm._v("Organización de la guía")]),_vm._v(" "),_c(\'p\',[_vm._v("Antes de comenzar a definir cada uno de los patrones de diseño, comentaré como será nuestro espacio de trabajo. En primer lugar, cada patrón será definido utilizando un ejemplo básico desarrollado en Java y a continuación, implementaré el patrón en una aplicación real.")]),_vm._v(" "),_c(\'p\',[_vm._v("La aplicación a desarrollar será una tienda online realizada en PHP y a medida que irás aprendiendo cada patrón, actualizaremos la tienda con el patrón correspondiente. Por lo tanto, si bien puedes estudiar los mismos por separado, para seguir el avance de esta tienda, te recomiendo que leas la presente guía en orden.")]),_vm._v(" "),_c(\'h2\',[_vm._v("Strategy (Estrategia)")]),_vm._v(" "),_c(\'p\',[_vm._v("El Patrón de Estrategia define una familia de algoritmos, encapsula cada uno y los hace intercambiables. La estrategia permite que el algoritmo varíe independientemente de los clientes que lo utilizan.")]),_vm._v(" "),_c(\'h2\',[_vm._v("Observer (Observador)")]),_vm._v(" "),_c(\'p\',[_vm._v("El Patrón de observador define una dependencia de uno a muchos entre objetos, de modo que cuando un objeto cambia de estado, todos sus dependientes son notificados y actualizados automáticamente.")]),_vm._v(" "),_c(\'h2\',[_vm._v("Abstract Factory (Fábrica Abstracta)")]),_vm._v(" "),_c(\'p\',[_vm._v("Proporciona una interfaz para crear familias de objetos relacionados o que dependen entre sí.")]),_vm._v(" "),_c(\'h2\',[_vm._v("Adapter (Adaptador)")]),_vm._v(" "),_c(\'p\',[_vm._v("Convierte la interfaz de una clase en otra distinta que es la que esperan los clientes. Permite que cooperen clases que de otra manera no podrían por tener interfaces incompatibles.")]),_vm._v(" "),_c(\'h2\',[_vm._v("Bridge (Puente)")]),_vm._v(" "),_c(\'p\',[_vm._v("Desacopla una abstracción de su implementación, de manera que ambas puedan variar de forma independiente.")]),_vm._v(" "),_c(\'h2\',[_vm._v("Builder (Constructor)")]),_vm._v(" "),_c(\'p\',[_vm._v("Separa la construcción de un objeto complejo de su representación, de forma que el mismo proceso de construcción pueda crear diferentes representaciones.")]),_vm._v(" "),_c(\'h2\',[_vm._v("Chain of Responsibility (Cadena de Responsabilidad)")]),_vm._v(" "),_c(\'p\',[_vm._v("Evita acoplar el emisor de una petición a su receptor, al dar a mas de un objeto la posibilidad de responder a la petición. Crea una cadena con los objetos receptores y pasa la petición a través de la cadena hasta que ésta sea trata por algún objeto.")]),_vm._v(" "),_c(\'h2\',[_vm._v("Command (Orden)")]),_vm._v(" "),_c(\'p\',[_vm._v("Encapsula una petición en un objeto, permitiendo así parametrizar a los clientes con distintas peticiones, encolar o llevar un registro de las peticiones y poder deshacer las operaciones.")]),_vm._v(" "),_c(\'h2\',[_vm._v("Composite (Compuesto)")]),_vm._v(" "),_c(\'p\',[_vm._v("Combina objetos en estructuras de árbol para representar jerarquías de parte-todo. Pemite que los clientes traten de manera uniforme a los objetos individuales y a los compuestos.")]),_vm._v(" "),_c(\'h2\',[_vm._v("Decorator (Decorador)")]),_vm._v(" "),_c(\'p\',[_vm._v("Añade dinámicamente nuevas responsabilidades a un objeto, proporcionando una alternativa flexible a la herencia para extender la funcionalidad.")]),_vm._v(" "),_c(\'h2\',[_vm._v("Facade (Fachada)")]),_vm._v(" "),_c(\'p\',[_vm._v("Proporciona una interfaz unificada para un conjunto de interfaces de un subsistema. Define una interfaz de alto nivel que hace que el subsistema sea más fácil de usar.")]),_vm._v(" "),_c(\'h2\',[_vm._v("Factory Method (Método de Fabricación)")]),_vm._v(" "),_c(\'p\',[_vm._v("Define una interfaz para crear un objeto, pero deja que sean las subclases quienes decidan que clase instanciar. Permite que una clase delegue en sus subclases la creación de objetos.")]),_vm._v(" "),_c(\'h2\',[_vm._v("Flyweight (Peso Ligero)")]),_vm._v(" "),_c(\'p\',[_vm._v("Usa el comportamiento para permitir un gran número de objetos de grano fino de forma eficiente.")]),_vm._v(" "),_c(\'h2\',[_vm._v("Interpreter (Intérprete)")]),_vm._v(" "),_c(\'p\',[_vm._v("Dado un lenguaje, define una representación de su gramática junto con un intérprete que usa dicha representación para interpretar sentencias del lenguaje.")]),_vm._v(" "),_c(\'h2\',[_vm._v("Iterator (Iterador)")]),_vm._v(" "),_c(\'p\',[_vm._v("Proporciona un modo de acceder secuencialmente a los elementos de un objeto agregado sin exponer su representación interna.")]),_vm._v(" "),_c(\'h2\',[_vm._v("Mediator (Mediador)")]),_vm._v(" "),_c(\'p\',[_vm._v("Define un objeto que encapsula cómo interactúan un conjunto de objetos. Promueve un bajo acoplamiento al evitar que los objetos se refieran unos a otros explícitamente, y permite variar la interacción entre ellos de forma independiente.")]),_vm._v(" "),_c(\'h2\',[_vm._v("Memento (Recuerdo)")]),_vm._v(" "),_c(\'p\',[_vm._v("Representa y externaliza el estado interno de un objeto sin violar la encapsulación, de forma que éste puede volver a dicho estado más tarde.")]),_vm._v(" "),_c(\'h2\',[_vm._v("Prototype (Prototipo)")]),_vm._v(" "),_c(\'p\',[_vm._v("Especifica los tipos de objetos a crear por medio de una instancia prototípica, y crea nuevos objetos copiando de este prototipo.")]),_vm._v(" "),_c(\'h2\',[_vm._v("Proxy (Apoderado)")]),_vm._v(" "),_c(\'p\',[_vm._v("Proporciona un sustituto o representante de otro objeto para controlar el acceso a éste.")]),_vm._v(" "),_c(\'h2\',[_vm._v("Singleton (Único)")]),_vm._v(" "),_c(\'p\',[_vm._v("Garantiza que una clase sólo tenga una instancia, y proporciona un punto de acceso global a ella.")]),_vm._v(" "),_c(\'h2\',[_vm._v("State (Estado)")]),_vm._v(" "),_c(\'p\',[_vm._v("Permite que un objeto modifique su comportamiento cada vez que cambie su estado interno. Parecerá que cambia la clase del objeto.")]),_vm._v(" "),_c(\'h2\',[_vm._v("Template Method (Método Plantilla)")]),_vm._v(" "),_c(\'p\',[_vm._v("Define en una operación el esqueleto de un algoritmo, delegando en las subclases algunos de sus pasos. Permite que las subclases redefinan ciertos pasos del algoritmo sin cambiar su estructura.")]),_vm._v(" "),_c(\'h2\',[_vm._v("Visitor (Visitante)")]),_vm._v(" "),_c(\'p\',[_vm._v("Representa una operación sobre los elementos de una estructura de objetos. Permite definir una nueva operación sin cambiar las clases de los elementos sobre los que opera.")])]) }]',component:{data:function(){return{templateRender:null}},render:function(e){return this.templateRender?this.templateRender():e("div","Rendering")},created:function(){this.templateRender=function(){var e=this.$createElement;this._self._c;return this._m(0)},this.$options.staticRenderFns=[function(){var e=this,n=e.$createElement,o=e._self._c||n;return o("div",{staticClass:"dynamicMarkdown"},[o("h1",[e._v("Patrones de diseño")]),e._v(" "),o("h2",[e._v("Introducción")]),e._v(" "),o("p",[e._v("En el desarrollo de sistemas, la mayoría de los programadores hoy en día, utilizan como metodología, la Programación Orientada a Objetos, de aquí en adelante, lo abreviaremos con sus siglas POO. Sabemos que programar en POO, no es muy sencillo, cuando los desarrollos tienden a complejizarse, el programador no experimentado no es capaz de determinar que clases elaborar. Los conceptos de la POO, no adquieren mayores dificultades a la hora de estudiarlos, el problema radica en como aplicar eficientemente estos conceptos en el desarrollo de aplicaciones medianamente complejas. Para facilitar el desarrollo, existen una serie de patrones, utilizados por una gran mayoría de desarrolladores experimentados, con el propósito de diseñar la arquitectura de sus proyectos.")]),e._v(" "),o("p",[e._v("En esta guía, vas a aprender a utilizar los diferentes patrones de diseño que podemos encontrar. Usted puede implementar estos patrones, en sus proyectos a medida que su aplicación lo requiera. Debes tener en cuenta, que cada aplicación es diferente, por lo tanto, su comportamiento y su jerarquía de clases será diferente, por eso es indispensable antes que nada, evaluar cual es el patrón de diseño que mejor se adapte a nuestra solución.")]),e._v(" "),o("h2",[e._v("Organización de la guía")]),e._v(" "),o("p",[e._v("Antes de comenzar a definir cada uno de los patrones de diseño, comentaré como será nuestro espacio de trabajo. En primer lugar, cada patrón será definido utilizando un ejemplo básico desarrollado en Java y a continuación, implementaré el patrón en una aplicación real.")]),e._v(" "),o("p",[e._v("La aplicación a desarrollar será una tienda online realizada en PHP y a medida que irás aprendiendo cada patrón, actualizaremos la tienda con el patrón correspondiente. Por lo tanto, si bien puedes estudiar los mismos por separado, para seguir el avance de esta tienda, te recomiendo que leas la presente guía en orden.")]),e._v(" "),o("h2",[e._v("Strategy (Estrategia)")]),e._v(" "),o("p",[e._v("El Patrón de Estrategia define una familia de algoritmos, encapsula cada uno y los hace intercambiables. La estrategia permite que el algoritmo varíe independientemente de los clientes que lo utilizan.")]),e._v(" "),o("h2",[e._v("Observer (Observador)")]),e._v(" "),o("p",[e._v("El Patrón de observador define una dependencia de uno a muchos entre objetos, de modo que cuando un objeto cambia de estado, todos sus dependientes son notificados y actualizados automáticamente.")]),e._v(" "),o("h2",[e._v("Abstract Factory (Fábrica Abstracta)")]),e._v(" "),o("p",[e._v("Proporciona una interfaz para crear familias de objetos relacionados o que dependen entre sí.")]),e._v(" "),o("h2",[e._v("Adapter (Adaptador)")]),e._v(" "),o("p",[e._v("Convierte la interfaz de una clase en otra distinta que es la que esperan los clientes. Permite que cooperen clases que de otra manera no podrían por tener interfaces incompatibles.")]),e._v(" "),o("h2",[e._v("Bridge (Puente)")]),e._v(" "),o("p",[e._v("Desacopla una abstracción de su implementación, de manera que ambas puedan variar de forma independiente.")]),e._v(" "),o("h2",[e._v("Builder (Constructor)")]),e._v(" "),o("p",[e._v("Separa la construcción de un objeto complejo de su representación, de forma que el mismo proceso de construcción pueda crear diferentes representaciones.")]),e._v(" "),o("h2",[e._v("Chain of Responsibility (Cadena de Responsabilidad)")]),e._v(" "),o("p",[e._v("Evita acoplar el emisor de una petición a su receptor, al dar a mas de un objeto la posibilidad de responder a la petición. Crea una cadena con los objetos receptores y pasa la petición a través de la cadena hasta que ésta sea trata por algún objeto.")]),e._v(" "),o("h2",[e._v("Command (Orden)")]),e._v(" "),o("p",[e._v("Encapsula una petición en un objeto, permitiendo así parametrizar a los clientes con distintas peticiones, encolar o llevar un registro de las peticiones y poder deshacer las operaciones.")]),e._v(" "),o("h2",[e._v("Composite (Compuesto)")]),e._v(" "),o("p",[e._v("Combina objetos en estructuras de árbol para representar jerarquías de parte-todo. Pemite que los clientes traten de manera uniforme a los objetos individuales y a los compuestos.")]),e._v(" "),o("h2",[e._v("Decorator (Decorador)")]),e._v(" "),o("p",[e._v("Añade dinámicamente nuevas responsabilidades a un objeto, proporcionando una alternativa flexible a la herencia para extender la funcionalidad.")]),e._v(" "),o("h2",[e._v("Facade (Fachada)")]),e._v(" "),o("p",[e._v("Proporciona una interfaz unificada para un conjunto de interfaces de un subsistema. Define una interfaz de alto nivel que hace que el subsistema sea más fácil de usar.")]),e._v(" "),o("h2",[e._v("Factory Method (Método de Fabricación)")]),e._v(" "),o("p",[e._v("Define una interfaz para crear un objeto, pero deja que sean las subclases quienes decidan que clase instanciar. Permite que una clase delegue en sus subclases la creación de objetos.")]),e._v(" "),o("h2",[e._v("Flyweight (Peso Ligero)")]),e._v(" "),o("p",[e._v("Usa el comportamiento para permitir un gran número de objetos de grano fino de forma eficiente.")]),e._v(" "),o("h2",[e._v("Interpreter (Intérprete)")]),e._v(" "),o("p",[e._v("Dado un lenguaje, define una representación de su gramática junto con un intérprete que usa dicha representación para interpretar sentencias del lenguaje.")]),e._v(" "),o("h2",[e._v("Iterator (Iterador)")]),e._v(" "),o("p",[e._v("Proporciona un modo de acceder secuencialmente a los elementos de un objeto agregado sin exponer su representación interna.")]),e._v(" "),o("h2",[e._v("Mediator (Mediador)")]),e._v(" "),o("p",[e._v("Define un objeto que encapsula cómo interactúan un conjunto de objetos. Promueve un bajo acoplamiento al evitar que los objetos se refieran unos a otros explícitamente, y permite variar la interacción entre ellos de forma independiente.")]),e._v(" "),o("h2",[e._v("Memento (Recuerdo)")]),e._v(" "),o("p",[e._v("Representa y externaliza el estado interno de un objeto sin violar la encapsulación, de forma que éste puede volver a dicho estado más tarde.")]),e._v(" "),o("h2",[e._v("Prototype (Prototipo)")]),e._v(" "),o("p",[e._v("Especifica los tipos de objetos a crear por medio de una instancia prototípica, y crea nuevos objetos copiando de este prototipo.")]),e._v(" "),o("h2",[e._v("Proxy (Apoderado)")]),e._v(" "),o("p",[e._v("Proporciona un sustituto o representante de otro objeto para controlar el acceso a éste.")]),e._v(" "),o("h2",[e._v("Singleton (Único)")]),e._v(" "),o("p",[e._v("Garantiza que una clase sólo tenga una instancia, y proporciona un punto de acceso global a ella.")]),e._v(" "),o("h2",[e._v("State (Estado)")]),e._v(" "),o("p",[e._v("Permite que un objeto modifique su comportamiento cada vez que cambie su estado interno. Parecerá que cambia la clase del objeto.")]),e._v(" "),o("h2",[e._v("Template Method (Método Plantilla)")]),e._v(" "),o("p",[e._v("Define en una operación el esqueleto de un algoritmo, delegando en las subclases algunos de sus pasos. Permite que las subclases redefinan ciertos pasos del algoritmo sin cambiar su estructura.")]),e._v(" "),o("h2",[e._v("Visitor (Visitante)")]),e._v(" "),o("p",[e._v("Representa una operación sobre los elementos de una estructura de objetos. Permite definir una nueva operación sin cambiar las clases de los elementos sobre los que opera.")])])}]}}}}}}]);